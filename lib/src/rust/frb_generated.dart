// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api/simple.dart';
import 'api/vtop/captcha_solver.dart';
import 'api/vtop/client/academic.dart';
import 'api/vtop/client/biometric.dart';
import 'api/vtop/client/course_page.dart';
import 'api/vtop/client/faculty.dart';
import 'api/vtop/client/hostel.dart';
import 'api/vtop/client/payment.dart';
import 'api/vtop/client/profile.dart';
import 'api/vtop/parser/attendance_parser.dart';
import 'api/vtop/parser/course_page_parser.dart';
import 'api/vtop/parser/exam_schedule_parser.dart';
import 'api/vtop/parser/faculty/parseabout.dart';
import 'api/vtop/parser/faculty/parsesearch.dart';
import 'api/vtop/parser/grade_history_parser.dart';
import 'api/vtop/parser/hostel/general_outing_parser.dart';
import 'api/vtop/parser/hostel/weekend_outing_parser.dart';
import 'api/vtop/parser/marks_parser.dart';
import 'api/vtop/parser/outing_form_parser.dart';
import 'api/vtop/parser/outing_response_parser.dart';
import 'api/vtop/parser/parse_biometric.dart';
import 'api/vtop/parser/payment_receipts_parser.dart';
import 'api/vtop/parser/pending_payments_parser.dart';
import 'api/vtop/parser/profile_parser.dart';
import 'api/vtop/parser/semested_id_parser.dart';
import 'api/vtop/parser/timetable_parser.dart';
import 'api/vtop/session_manager.dart';
import 'api/vtop/types/attendance.dart';
import 'api/vtop/types/biometric.dart';
import 'api/vtop/types/course_page.dart';
import 'api/vtop/types/exam_schedule.dart';
import 'api/vtop/types/faculty.dart';
import 'api/vtop/types/general_outing.dart';
import 'api/vtop/types/grade_course_history.dart';
import 'api/vtop/types/grade_history.dart';
import 'api/vtop/types/marks.dart';
import 'api/vtop/types/mentor_details.dart';
import 'api/vtop/types/outing_info.dart';
import 'api/vtop/types/paid_payment_receipt.dart';
import 'api/vtop/types/pending_payment_receipt.dart';
import 'api/vtop/types/semester.dart';
import 'api/vtop/types/student_profile.dart';
import 'api/vtop/types/timetable.dart';
import 'api/vtop/types/weekend_outing.dart';
import 'api/vtop/vtop_client.dart';
import 'api/vtop/vtop_config.dart';
import 'api/vtop/vtop_errors.dart';
import 'api/vtop/wifi.dart';
import 'api/vtop_get_client.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:meta/meta.dart' as meta;

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
    bool forceSameCodegenVersion = true,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
      forceSameCodegenVersion: forceSameCodegenVersion,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {
    await api.crateApiSimpleInitApp();
  }

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.11.1';

  @override
  int get rustContentHash => 971532992;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'lib_vtop',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<VtopResult>
      crateApiVtopSessionManagerSessionManagerCheckSessionExpiration(
          {required SessionManager that, required Response response});

  Future<void> crateApiVtopSessionManagerSessionManagerClear(
      {required SessionManager that});

  Future<ArcJar> crateApiVtopSessionManagerSessionManagerGetCookieStore(
      {required SessionManager that});

  Future<String?> crateApiVtopSessionManagerSessionManagerGetCsrfToken(
      {required SessionManager that});

  Future<bool> crateApiVtopSessionManagerSessionManagerIsAuthenticated(
      {required SessionManager that});

  Future<SessionManager> crateApiVtopSessionManagerSessionManagerNew();

  Future<void> crateApiVtopSessionManagerSessionManagerSetAuthenticated(
      {required SessionManager that, required bool authenticated});

  Future<void> crateApiVtopSessionManagerSessionManagerSetCsrfFromExternal(
      {required SessionManager that, required String token});

  Future<void> crateApiVtopSessionManagerSessionManagerSetCsrfToken(
      {required SessionManager that, required String token});

  Future<VtopClient> crateApiVtopVtopConfigVtopClientBuilderBuild(
      {required VtopClientBuilder that,
      required String username,
      required String password});

  Future<VtopClientBuilder> crateApiVtopVtopConfigVtopClientBuilderNew();

  Future<VtopResultString> crateApiVtopVtopClientVtopClientDeleteGeneralOuting(
      {required VtopClient that, required String leaveId});

  Future<VtopResultString> crateApiVtopVtopClientVtopClientDeleteWeekendOuting(
      {required VtopClient that, required String bookingId});

  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadAllCourseMaterials(
          {required VtopClient that, required String downloadPath});

  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadCourseMaterial(
          {required VtopClient that, required String downloadPath});

  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadCoursePlanExcel(
          {required VtopClient that,
          required String semesterId,
          required String classId});

  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadCourseSyllabus(
          {required VtopClient that,
          required String courseId,
          required String courseType});

  Future<VtopResultString>
      crateApiVtopVtopClientVtopClientDownloadPaymentReceipt(
          {required VtopClient that,
          required String receiptNo,
          required String applno});

  Future<VtopResultVecAttendanceRecord>
      crateApiVtopVtopClientVtopClientGetAttendance(
          {required VtopClient that, required String semesterId});

  Future<VtopResultVecAttendanceDetailRecord>
      crateApiVtopVtopClientVtopClientGetAttendanceDetail(
          {required VtopClient that,
          required String semesterId,
          required String courseId,
          required String courseType});

  Future<VtopResultVecBiometricRecord>
      crateApiVtopVtopClientVtopClientGetBiometricData(
          {required VtopClient that, required String date});

  Future<VtopResultVecU8> crateApiVtopVtopClientVtopClientGetCookie(
      {required VtopClient that});

  Future<VtopResultCoursePageDetail>
      crateApiVtopVtopClientVtopClientGetCourseDetail(
          {required VtopClient that,
          required String semesterId,
          required String erpId,
          required String classId});

  Future<VtopResultCoursesResponse>
      crateApiVtopVtopClientVtopClientGetCoursesForCoursePage(
          {required VtopClient that, required String semesterId});

  Future<VtopResultVecPerExamScheduleRecord>
      crateApiVtopVtopClientVtopClientGetExamSchedule(
          {required VtopClient that, required String semesterId});

  Future<VtopResultFacultyDetails>
      crateApiVtopVtopClientVtopClientGetFacultyData(
          {required VtopClient that, required String empId});

  Future<VtopResultGetFaculty> crateApiVtopVtopClientVtopClientGetFacultySearch(
      {required VtopClient that, required String searchTerm});

  Future<VtopResultVecU8> crateApiVtopVtopClientVtopClientGetGeneralOutingPdf(
      {required VtopClient that, required String leaveId});

  Future<VtopResultVecGeneralOutingRecord>
      crateApiVtopVtopClientVtopClientGetGeneralOutingReports(
          {required VtopClient that});

  Future<VtopResultGradeHistory>
      crateApiVtopVtopClientVtopClientGetGradeHistory(
          {required VtopClient that});

  Future<VtopResultVecU8> crateApiVtopVtopClientVtopClientGetHostelOutingPdf(
      {required VtopClient that, required String bookingId});

  Future<VtopResultVecMarks> crateApiVtopVtopClientVtopClientGetMarks(
      {required VtopClient that, required String semesterId});

  Future<VtopResultVecPaidPaymentReceipt>
      crateApiVtopVtopClientVtopClientGetPaymentReceipts(
          {required VtopClient that});

  Future<VtopResultVecPendingPaymentReceipt>
      crateApiVtopVtopClientVtopClientGetPendingPayment(
          {required VtopClient that});

  Future<VtopResultSemesterData> crateApiVtopVtopClientVtopClientGetSemesters(
      {required VtopClient that});

  Future<VtopResultSlotsResponse>
      crateApiVtopVtopClientVtopClientGetSlotsForCoursePage(
          {required VtopClient that,
          required String semesterId,
          required String classId});

  Future<VtopResultStudentProfile>
      crateApiVtopVtopClientVtopClientGetStudentProfile(
          {required VtopClient that});

  Future<VtopResultTimetable> crateApiVtopVtopClientVtopClientGetTimetable(
      {required VtopClient that, required String semesterId});

  Future<VtopResultVecWeekendOutingRecord>
      crateApiVtopVtopClientVtopClientGetWeekendOutingReports(
          {required VtopClient that});

  Future<VtopResultString> crateApiVtopVtopClientVtopClientInitCoursePage(
      {required VtopClient that});

  Future<bool> crateApiVtopVtopClientVtopClientIsAuthenticated(
      {required VtopClient that});

  Future<VtopResult> crateApiVtopVtopClientVtopClientLogin(
      {required VtopClient that});

  Future<VtopResultString>
      crateApiVtopVtopClientVtopClientSubmitGeneralOutingForm(
          {required VtopClient that,
          required String outPlace,
          required String purposeOfVisit,
          required String outingDate,
          required String outTime,
          required String inDate,
          required String inTime});

  Future<VtopResultString>
      crateApiVtopVtopClientVtopClientSubmitWeekendOutingForm(
          {required VtopClient that,
          required String outPlace,
          required String purposeOfVisit,
          required String outingDate,
          required String outTime,
          required String contactNumber});

  Future<VtopClient> crateApiVtopVtopClientVtopClientWithConfig(
      {required VtopConfig config,
      required SessionManager session,
      required String username,
      required String password});

  Future<String> crateApiVtopGetClientDeleteGeneralOuting(
      {required VtopClient client, required String leaveId});

  Future<String> crateApiVtopGetClientDeleteWeekendOuting(
      {required VtopClient client, required String bookingId});

  Future<Uint8List> crateApiVtopGetClientDownloadAllCourseMaterials(
      {required VtopClient client, required String downloadPath});

  Future<Uint8List> crateApiVtopGetClientDownloadCourseMaterial(
      {required VtopClient client, required String downloadPath});

  Future<Uint8List> crateApiVtopGetClientDownloadCoursePlanExcel(
      {required VtopClient client,
      required String semesterId,
      required String classId});

  Future<Uint8List> crateApiVtopGetClientDownloadCourseSyllabus(
      {required VtopClient client,
      required String courseId,
      required String courseType});

  Future<String> crateApiVtopGetClientFetchAllData(
      {required VtopClient client, required String semesterId});

  Future<String> crateApiVtopGetClientFetchAttendance(
      {required VtopClient client, required String semesterId});

  Future<String> crateApiVtopGetClientFetchAttendanceDetail(
      {required VtopClient client,
      required String semesterId,
      required String courseId,
      required String courseType});

  Future<String> crateApiVtopGetClientFetchBiometricData(
      {required VtopClient client, required String date});

  Future<Uint8List> crateApiVtopGetClientFetchCookies(
      {required VtopClient client});

  Future<String> crateApiVtopGetClientFetchCourseDetail(
      {required VtopClient client,
      required String semesterId,
      required String erpId,
      required String classId});

  Future<String> crateApiVtopGetClientFetchCoursesForCoursePage(
      {required VtopClient client, required String semesterId});

  Future<String?> crateApiVtopGetClientFetchCsrfToken(
      {required VtopClient client});

  Future<String> crateApiVtopGetClientFetchExamShedule(
      {required VtopClient client, required String semesterId});

  Future<FacultyDetails> crateApiVtopGetClientFetchFacultyData(
      {required VtopClient client, required String empId});

  Future<GetFaculty> crateApiVtopGetClientFetchFacultySearch(
      {required VtopClient client, required String searchTerm});

  Future<Uint8List> crateApiVtopGetClientFetchGeneralOutingPdf(
      {required VtopClient client, required String leaveId});

  Future<String> crateApiVtopGetClientFetchGeneralOutingReports(
      {required VtopClient client});

  Future<GradeHistory> crateApiVtopGetClientFetchGradeHistory(
      {required VtopClient client});

  Future<bool> crateApiVtopGetClientFetchIsAuth({required VtopClient client});

  Future<String> crateApiVtopGetClientFetchMarks(
      {required VtopClient client, required String semesterId});

  Future<String> crateApiVtopGetClientFetchPaymentReceipts(
      {required VtopClient client});

  Future<String> crateApiVtopGetClientFetchPendingPayments(
      {required VtopClient client});

  Future<SemesterData> crateApiVtopGetClientFetchSemesters(
      {required VtopClient client});

  Future<String> crateApiVtopGetClientFetchSlotsForCoursePage(
      {required VtopClient client,
      required String semesterId,
      required String classId});

  Future<String> crateApiVtopGetClientFetchStudentProfile(
      {required VtopClient client});

  Future<String> crateApiVtopGetClientFetchTimetable(
      {required VtopClient client, required String semesterId});

  Future<String> crateApiVtopGetClientFetchUsername(
      {required VtopClient client});

  Future<Uint8List> crateApiVtopGetClientFetchWeekendOutingPdf(
      {required VtopClient client, required String bookingId});

  Future<String> crateApiVtopGetClientFetchWeekendOutingReports(
      {required VtopClient client});

  Future<(bool, String)> crateApiVtopGetClientFetchWifi(
      {required String username, required String password, required int i});

  VtopClient crateApiVtopGetClientGetVtopClient(
      {required String username, required String password});

  String crateApiSimpleGreet({required String name});

  Future<void> crateApiSimpleInitApp();

  Future<String> crateApiVtopGetClientInitCoursePage(
      {required VtopClient client});

  Future<List<AttendanceRecord>>
      crateApiVtopParserAttendanceParserParseAttendance({required String html});

  Future<List<BiometricRecord>>
      crateApiVtopParserParseBiometricParseBiometricData(
          {required String html});

  Future<CoursePageDetail>
      crateApiVtopParserCoursePageParserParseCourseDetailPage(
          {required String html});

  Future<CoursesResponse>
      crateApiVtopParserCoursePageParserParseCoursesForCoursePage(
          {required String html});

  Future<FacultyDetails> crateApiVtopParserFacultyParseaboutParseFacultyData(
      {required String html});

  Future<GetFaculty> crateApiVtopParserFacultyParsesearchParseFacultySearch(
      {required String html});

  Future<List<AttendanceDetailRecord>>
      crateApiVtopParserAttendanceParserParseFullAttendance(
          {required String html});

  Future<GradeHistory> crateApiVtopParserGradeHistoryParserParseGradeHistory(
      {required String html});

  Future<List<GeneralOutingRecord>>
      crateApiVtopParserHostelGeneralOutingParserParseHostelLeave(
          {required String html});

  Future<List<Marks>> crateApiVtopParserMarksParserParseMarks(
      {required String html});

  Future<OutingInfo> crateApiVtopParserOutingFormParserParseOutingForm(
      {required String html});

  Future<String> crateApiVtopParserOutingResponseParserParseOutingResponse(
      {required String html});

  Future<List<PaidPaymentReceipt>>
      crateApiVtopParserPaymentReceiptsParserParsePaymentReceipts(
          {required String html});

  Future<List<PendingPaymentReceipt>>
      crateApiVtopParserPendingPaymentsParserParsePendingPayments(
          {required String html});

  Future<List<PerExamScheduleRecord>>
      crateApiVtopParserExamScheduleParserParseSchedule({required String html});

  Future<SemesterData>
      crateApiVtopParserSemestedIdParserParseSemidFromTimetable(
          {required String html});

  Future<SlotsResponse>
      crateApiVtopParserCoursePageParserParseSlotsForCoursePage(
          {required String html, required String semesterId});

  Future<StudentProfile> crateApiVtopParserProfileParserParseStudentProfile(
      {required String html});

  Future<Timetable> crateApiVtopParserTimetableParserParseTimetable(
      {required String html});

  Future<List<WeekendOutingRecord>>
      crateApiVtopParserHostelWeekendOutingParserParseWeekendOuting(
          {required String html});

  Future<VtopResultString> crateApiVtopCaptchaSolverSolveCaptcha(
      {required String captchaData});

  Future<String> crateApiVtopGetClientStudentPaymentReceiptDownload(
      {required VtopClient client,
      required String receiptNo,
      required String applno});

  Future<String> crateApiVtopGetClientSubmitGeneralOutingForm(
      {required VtopClient client,
      required String outPlace,
      required String purposeOfVisit,
      required String outingDate,
      required String outTime,
      required String inDate,
      required String inTime});

  Future<String> crateApiVtopGetClientSubmitWeekendOutingForm(
      {required VtopClient client,
      required String outPlace,
      required String purposeOfVisit,
      required String outingDate,
      required String outTime,
      required String contactNumber});

  Future<(bool, String)> crateApiVtopWifiUniversityWifiLoginLogout(
      {required int i, required String username, required String password});

  Future<void> crateApiVtopGetClientVtopClientLogin(
      {required VtopClient client});

  Future<VtopConfig> crateApiVtopVtopConfigVtopConfigDefault();

  Future<String> crateApiVtopVtopErrorsVtopErrorDebugMessage(
      {required VtopError that});

  Future<String> crateApiVtopVtopErrorsVtopErrorErrorType(
      {required VtopError that});

  Future<String> crateApiVtopVtopErrorsVtopErrorMessage(
      {required VtopError that});

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_ArcJar;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_ArcJar;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ArcJarPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Response;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Response;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ResponsePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SessionManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SessionManager;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SessionManagerPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopClient;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_VtopClientPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopClientBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopClientBuilder;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopClientBuilderPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResult;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResult;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_VtopResultPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultCoursePageDetail;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultCoursePageDetail;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultCoursePageDetailPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultCoursesResponse;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultCoursesResponse;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultCoursesResponsePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultFacultyDetails;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultFacultyDetails;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultFacultyDetailsPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultGetFaculty;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultGetFaculty;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultGetFacultyPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultGradeHistory;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultGradeHistory;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultGradeHistoryPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultSemesterData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultSemesterData;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultSemesterDataPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultSlotsResponse;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultSlotsResponse;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultSlotsResponsePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultString;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultString;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultStringPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultStudentProfile;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultStudentProfile;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultStudentProfilePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultTimetable;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultTimetable;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultTimetablePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecAttendanceDetailRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecAttendanceDetailRecord;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecAttendanceDetailRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecAttendanceRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecAttendanceRecord;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecAttendanceRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecBiometricRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecBiometricRecord;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecBiometricRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecGeneralOutingRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecGeneralOutingRecord;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecGeneralOutingRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecMarks;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecMarks;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecMarksPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecPaidPaymentReceipt;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecPaidPaymentReceipt;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecPaidPaymentReceiptPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecPendingPaymentReceipt;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecPendingPaymentReceipt;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecPendingPaymentReceiptPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecPerExamScheduleRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecPerExamScheduleRecord;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecPerExamScheduleRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecWeekendOutingRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecWeekendOutingRecord;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecWeekendOutingRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecU8;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecU8;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_VtopResultVecU8Ptr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<VtopResult>
      crateApiVtopSessionManagerSessionManagerCheckSessionExpiration(
          {required SessionManager that, required Response response}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
            response, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopSessionManagerSessionManagerCheckSessionExpirationConstMeta,
      argValues: [that, response],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerCheckSessionExpirationConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_check_session_expiration",
            argNames: ["that", "response"],
          );

  @override
  Future<void> crateApiVtopSessionManagerSessionManagerClear(
      {required SessionManager that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 2, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopSessionManagerSessionManagerClearConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopSessionManagerSessionManagerClearConstMeta =>
      const TaskConstMeta(
        debugName: "SessionManager_clear",
        argNames: ["that"],
      );

  @override
  Future<ArcJar> crateApiVtopSessionManagerSessionManagerGetCookieStore(
      {required SessionManager that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 3, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopSessionManagerSessionManagerGetCookieStoreConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerGetCookieStoreConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_get_cookie_store",
            argNames: ["that"],
          );

  @override
  Future<String?> crateApiVtopSessionManagerSessionManagerGetCsrfToken(
      {required SessionManager that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 4, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopSessionManagerSessionManagerGetCsrfTokenConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerGetCsrfTokenConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_get_csrf_token",
            argNames: ["that"],
          );

  @override
  Future<bool> crateApiVtopSessionManagerSessionManagerIsAuthenticated(
      {required SessionManager that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopSessionManagerSessionManagerIsAuthenticatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerIsAuthenticatedConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_is_authenticated",
            argNames: ["that"],
          );

  @override
  Future<SessionManager> crateApiVtopSessionManagerSessionManagerNew() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopSessionManagerSessionManagerNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopSessionManagerSessionManagerNewConstMeta =>
      const TaskConstMeta(
        debugName: "SessionManager_new",
        argNames: [],
      );

  @override
  Future<void> crateApiVtopSessionManagerSessionManagerSetAuthenticated(
      {required SessionManager that, required bool authenticated}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        sse_encode_bool(authenticated, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopSessionManagerSessionManagerSetAuthenticatedConstMeta,
      argValues: [that, authenticated],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerSetAuthenticatedConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_set_authenticated",
            argNames: ["that", "authenticated"],
          );

  @override
  Future<void> crateApiVtopSessionManagerSessionManagerSetCsrfFromExternal(
      {required SessionManager that, required String token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        sse_encode_String(token, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopSessionManagerSessionManagerSetCsrfFromExternalConstMeta,
      argValues: [that, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerSetCsrfFromExternalConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_set_csrf_from_external",
            argNames: ["that", "token"],
          );

  @override
  Future<void> crateApiVtopSessionManagerSessionManagerSetCsrfToken(
      {required SessionManager that, required String token}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            that, serializer);
        sse_encode_String(token, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopSessionManagerSessionManagerSetCsrfTokenConstMeta,
      argValues: [that, token],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopSessionManagerSessionManagerSetCsrfTokenConstMeta =>
          const TaskConstMeta(
            debugName: "SessionManager_set_csrf_token",
            argNames: ["that", "token"],
          );

  @override
  Future<VtopClient> crateApiVtopVtopConfigVtopClientBuilderBuild(
      {required VtopClientBuilder that,
      required String username,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
            that, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 10, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopConfigVtopClientBuilderBuildConstMeta,
      argValues: [that, username, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopConfigVtopClientBuilderBuildConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClientBuilder_build",
        argNames: ["that", "username", "password"],
      );

  @override
  Future<VtopClientBuilder> crateApiVtopVtopConfigVtopClientBuilderNew() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopConfigVtopClientBuilderNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopConfigVtopClientBuilderNewConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClientBuilder_new",
        argNames: [],
      );

  @override
  Future<VtopResultString> crateApiVtopVtopClientVtopClientDeleteGeneralOuting(
      {required VtopClient that, required String leaveId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(leaveId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientDeleteGeneralOutingConstMeta,
      argValues: [that, leaveId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDeleteGeneralOutingConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_delete_general_outing",
            argNames: ["that", "leaveId"],
          );

  @override
  Future<VtopResultString> crateApiVtopVtopClientVtopClientDeleteWeekendOuting(
      {required VtopClient that, required String bookingId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(bookingId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientDeleteWeekendOutingConstMeta,
      argValues: [that, bookingId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDeleteWeekendOutingConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_delete_weekend_outing",
            argNames: ["that", "bookingId"],
          );

  @override
  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadAllCourseMaterials(
          {required VtopClient that, required String downloadPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(downloadPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 14, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientDownloadAllCourseMaterialsConstMeta,
      argValues: [that, downloadPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDownloadAllCourseMaterialsConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_download_all_course_materials",
            argNames: ["that", "downloadPath"],
          );

  @override
  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadCourseMaterial(
          {required VtopClient that, required String downloadPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(downloadPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 15, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientDownloadCourseMaterialConstMeta,
      argValues: [that, downloadPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDownloadCourseMaterialConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_download_course_material",
            argNames: ["that", "downloadPath"],
          );

  @override
  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadCoursePlanExcel(
          {required VtopClient that,
          required String semesterId,
          required String classId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(classId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 16, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientDownloadCoursePlanExcelConstMeta,
      argValues: [that, semesterId, classId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDownloadCoursePlanExcelConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_download_course_plan_excel",
            argNames: ["that", "semesterId", "classId"],
          );

  @override
  Future<VtopResultVecU8>
      crateApiVtopVtopClientVtopClientDownloadCourseSyllabus(
          {required VtopClient that,
          required String courseId,
          required String courseType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(courseId, serializer);
        sse_encode_String(courseType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 17, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientDownloadCourseSyllabusConstMeta,
      argValues: [that, courseId, courseType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDownloadCourseSyllabusConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_download_course_syllabus",
            argNames: ["that", "courseId", "courseType"],
          );

  @override
  Future<VtopResultString>
      crateApiVtopVtopClientVtopClientDownloadPaymentReceipt(
          {required VtopClient that,
          required String receiptNo,
          required String applno}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(receiptNo, serializer);
        sse_encode_String(applno, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 18, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientDownloadPaymentReceiptConstMeta,
      argValues: [that, receiptNo, applno],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientDownloadPaymentReceiptConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_download_payment_receipt",
            argNames: ["that", "receiptNo", "applno"],
          );

  @override
  Future<VtopResultVecAttendanceRecord>
      crateApiVtopVtopClientVtopClientGetAttendance(
          {required VtopClient that, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 19, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetAttendanceConstMeta,
      argValues: [that, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetAttendanceConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_attendance",
        argNames: ["that", "semesterId"],
      );

  @override
  Future<VtopResultVecAttendanceDetailRecord>
      crateApiVtopVtopClientVtopClientGetAttendanceDetail(
          {required VtopClient that,
          required String semesterId,
          required String courseId,
          required String courseType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(courseId, serializer);
        sse_encode_String(courseType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 20, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetAttendanceDetailConstMeta,
      argValues: [that, semesterId, courseId, courseType],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetAttendanceDetailConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_attendance_detail",
            argNames: ["that", "semesterId", "courseId", "courseType"],
          );

  @override
  Future<VtopResultVecBiometricRecord>
      crateApiVtopVtopClientVtopClientGetBiometricData(
          {required VtopClient that, required String date}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(date, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 21, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetBiometricDataConstMeta,
      argValues: [that, date],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetBiometricDataConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_biometric_data",
            argNames: ["that", "date"],
          );

  @override
  Future<VtopResultVecU8> crateApiVtopVtopClientVtopClientGetCookie(
      {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 22, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetCookieConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetCookieConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_cookie",
        argNames: ["that"],
      );

  @override
  Future<VtopResultCoursePageDetail>
      crateApiVtopVtopClientVtopClientGetCourseDetail(
          {required VtopClient that,
          required String semesterId,
          required String erpId,
          required String classId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(erpId, serializer);
        sse_encode_String(classId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 23, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetCourseDetailConstMeta,
      argValues: [that, semesterId, erpId, classId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetCourseDetailConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_course_detail",
        argNames: ["that", "semesterId", "erpId", "classId"],
      );

  @override
  Future<VtopResultCoursesResponse>
      crateApiVtopVtopClientVtopClientGetCoursesForCoursePage(
          {required VtopClient that, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 24, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientGetCoursesForCoursePageConstMeta,
      argValues: [that, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetCoursesForCoursePageConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_courses_for_course_page",
            argNames: ["that", "semesterId"],
          );

  @override
  Future<VtopResultVecPerExamScheduleRecord>
      crateApiVtopVtopClientVtopClientGetExamSchedule(
          {required VtopClient that, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 25, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetExamScheduleConstMeta,
      argValues: [that, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetExamScheduleConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_exam_schedule",
        argNames: ["that", "semesterId"],
      );

  @override
  Future<VtopResultFacultyDetails>
      crateApiVtopVtopClientVtopClientGetFacultyData(
          {required VtopClient that, required String empId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(empId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 26, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetFacultyDataConstMeta,
      argValues: [that, empId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetFacultyDataConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_faculty_data",
        argNames: ["that", "empId"],
      );

  @override
  Future<VtopResultGetFaculty> crateApiVtopVtopClientVtopClientGetFacultySearch(
      {required VtopClient that, required String searchTerm}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(searchTerm, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 27, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetFacultySearchConstMeta,
      argValues: [that, searchTerm],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetFacultySearchConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_faculty_search",
            argNames: ["that", "searchTerm"],
          );

  @override
  Future<VtopResultVecU8> crateApiVtopVtopClientVtopClientGetGeneralOutingPdf(
      {required VtopClient that, required String leaveId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(leaveId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetGeneralOutingPdfConstMeta,
      argValues: [that, leaveId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetGeneralOutingPdfConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_general_outing_pdf",
            argNames: ["that", "leaveId"],
          );

  @override
  Future<VtopResultVecGeneralOutingRecord>
      crateApiVtopVtopClientVtopClientGetGeneralOutingReports(
          {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientGetGeneralOutingReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetGeneralOutingReportsConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_general_outing_reports",
            argNames: ["that"],
          );

  @override
  Future<VtopResultGradeHistory>
      crateApiVtopVtopClientVtopClientGetGradeHistory(
          {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetGradeHistoryConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetGradeHistoryConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_grade_history",
        argNames: ["that"],
      );

  @override
  Future<VtopResultVecU8> crateApiVtopVtopClientVtopClientGetHostelOutingPdf(
      {required VtopClient that, required String bookingId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(bookingId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetHostelOutingPdfConstMeta,
      argValues: [that, bookingId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetHostelOutingPdfConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_hostel_outing_pdf",
            argNames: ["that", "bookingId"],
          );

  @override
  Future<VtopResultVecMarks> crateApiVtopVtopClientVtopClientGetMarks(
      {required VtopClient that, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetMarksConstMeta,
      argValues: [that, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetMarksConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_marks",
        argNames: ["that", "semesterId"],
      );

  @override
  Future<VtopResultVecPaidPaymentReceipt>
      crateApiVtopVtopClientVtopClientGetPaymentReceipts(
          {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetPaymentReceiptsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetPaymentReceiptsConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_payment_receipts",
            argNames: ["that"],
          );

  @override
  Future<VtopResultVecPendingPaymentReceipt>
      crateApiVtopVtopClientVtopClientGetPendingPayment(
          {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 34, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetPendingPaymentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetPendingPaymentConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_pending_payment",
            argNames: ["that"],
          );

  @override
  Future<VtopResultSemesterData> crateApiVtopVtopClientVtopClientGetSemesters(
      {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetSemestersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetSemestersConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_semesters",
        argNames: ["that"],
      );

  @override
  Future<VtopResultSlotsResponse>
      crateApiVtopVtopClientVtopClientGetSlotsForCoursePage(
          {required VtopClient that,
          required String semesterId,
          required String classId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(classId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 36, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientGetSlotsForCoursePageConstMeta,
      argValues: [that, semesterId, classId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetSlotsForCoursePageConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_slots_for_course_page",
            argNames: ["that", "semesterId", "classId"],
          );

  @override
  Future<VtopResultStudentProfile>
      crateApiVtopVtopClientVtopClientGetStudentProfile(
          {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 37, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetStudentProfileConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetStudentProfileConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_student_profile",
            argNames: ["that"],
          );

  @override
  Future<VtopResultTimetable> crateApiVtopVtopClientVtopClientGetTimetable(
      {required VtopClient that, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 38, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientGetTimetableConstMeta,
      argValues: [that, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientGetTimetableConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_get_timetable",
        argNames: ["that", "semesterId"],
      );

  @override
  Future<VtopResultVecWeekendOutingRecord>
      crateApiVtopVtopClientVtopClientGetWeekendOutingReports(
          {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 39, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientGetWeekendOutingReportsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientGetWeekendOutingReportsConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_get_weekend_outing_reports",
            argNames: ["that"],
          );

  @override
  Future<VtopResultString> crateApiVtopVtopClientVtopClientInitCoursePage(
      {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientInitCoursePageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientInitCoursePageConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_init_course_page",
        argNames: ["that"],
      );

  @override
  Future<bool> crateApiVtopVtopClientVtopClientIsAuthenticated(
      {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientIsAuthenticatedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientIsAuthenticatedConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_is_authenticated",
        argNames: ["that"],
      );

  @override
  Future<VtopResult> crateApiVtopVtopClientVtopClientLogin(
      {required VtopClient that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientLoginConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientLoginConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_login",
        argNames: ["that"],
      );

  @override
  Future<VtopResultString>
      crateApiVtopVtopClientVtopClientSubmitGeneralOutingForm(
          {required VtopClient that,
          required String outPlace,
          required String purposeOfVisit,
          required String outingDate,
          required String outTime,
          required String inDate,
          required String inTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(outPlace, serializer);
        sse_encode_String(purposeOfVisit, serializer);
        sse_encode_String(outingDate, serializer);
        sse_encode_String(outTime, serializer);
        sse_encode_String(inDate, serializer);
        sse_encode_String(inTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientSubmitGeneralOutingFormConstMeta,
      argValues: [
        that,
        outPlace,
        purposeOfVisit,
        outingDate,
        outTime,
        inDate,
        inTime
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientSubmitGeneralOutingFormConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_submit_general_outing_form",
            argNames: [
              "that",
              "outPlace",
              "purposeOfVisit",
              "outingDate",
              "outTime",
              "inDate",
              "inTime"
            ],
          );

  @override
  Future<VtopResultString>
      crateApiVtopVtopClientVtopClientSubmitWeekendOutingForm(
          {required VtopClient that,
          required String outPlace,
          required String purposeOfVisit,
          required String outingDate,
          required String outTime,
          required String contactNumber}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            that, serializer);
        sse_encode_String(outPlace, serializer);
        sse_encode_String(purposeOfVisit, serializer);
        sse_encode_String(outingDate, serializer);
        sse_encode_String(outTime, serializer);
        sse_encode_String(contactNumber, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopVtopClientVtopClientSubmitWeekendOutingFormConstMeta,
      argValues: [
        that,
        outPlace,
        purposeOfVisit,
        outingDate,
        outTime,
        contactNumber
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopVtopClientVtopClientSubmitWeekendOutingFormConstMeta =>
          const TaskConstMeta(
            debugName: "VtopClient_submit_weekend_outing_form",
            argNames: [
              "that",
              "outPlace",
              "purposeOfVisit",
              "outingDate",
              "outTime",
              "contactNumber"
            ],
          );

  @override
  Future<VtopClient> crateApiVtopVtopClientVtopClientWithConfig(
      {required VtopConfig config,
      required SessionManager session,
      required String username,
      required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_vtop_config(config, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
            session, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopClientVtopClientWithConfigConstMeta,
      argValues: [config, session, username, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopClientVtopClientWithConfigConstMeta =>
      const TaskConstMeta(
        debugName: "VtopClient_with_config",
        argNames: ["config", "session", "username", "password"],
      );

  @override
  Future<String> crateApiVtopGetClientDeleteGeneralOuting(
      {required VtopClient client, required String leaveId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(leaveId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientDeleteGeneralOutingConstMeta,
      argValues: [client, leaveId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientDeleteGeneralOutingConstMeta =>
      const TaskConstMeta(
        debugName: "delete_general_outing",
        argNames: ["client", "leaveId"],
      );

  @override
  Future<String> crateApiVtopGetClientDeleteWeekendOuting(
      {required VtopClient client, required String bookingId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(bookingId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientDeleteWeekendOutingConstMeta,
      argValues: [client, bookingId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientDeleteWeekendOutingConstMeta =>
      const TaskConstMeta(
        debugName: "delete_weekend_outing",
        argNames: ["client", "bookingId"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientDownloadAllCourseMaterials(
      {required VtopClient client, required String downloadPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(downloadPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientDownloadAllCourseMaterialsConstMeta,
      argValues: [client, downloadPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientDownloadAllCourseMaterialsConstMeta =>
      const TaskConstMeta(
        debugName: "download_all_course_materials",
        argNames: ["client", "downloadPath"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientDownloadCourseMaterial(
      {required VtopClient client, required String downloadPath}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(downloadPath, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientDownloadCourseMaterialConstMeta,
      argValues: [client, downloadPath],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientDownloadCourseMaterialConstMeta =>
      const TaskConstMeta(
        debugName: "download_course_material",
        argNames: ["client", "downloadPath"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientDownloadCoursePlanExcel(
      {required VtopClient client,
      required String semesterId,
      required String classId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(classId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientDownloadCoursePlanExcelConstMeta,
      argValues: [client, semesterId, classId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientDownloadCoursePlanExcelConstMeta =>
      const TaskConstMeta(
        debugName: "download_course_plan_excel",
        argNames: ["client", "semesterId", "classId"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientDownloadCourseSyllabus(
      {required VtopClient client,
      required String courseId,
      required String courseType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(courseId, serializer);
        sse_encode_String(courseType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientDownloadCourseSyllabusConstMeta,
      argValues: [client, courseId, courseType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientDownloadCourseSyllabusConstMeta =>
      const TaskConstMeta(
        debugName: "download_course_syllabus",
        argNames: ["client", "courseId", "courseType"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchAllData(
      {required VtopClient client, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchAllDataConstMeta,
      argValues: [client, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchAllDataConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_all_data",
        argNames: ["client", "semesterId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchAttendance(
      {required VtopClient client, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchAttendanceConstMeta,
      argValues: [client, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchAttendanceConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_attendance",
        argNames: ["client", "semesterId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchAttendanceDetail(
      {required VtopClient client,
      required String semesterId,
      required String courseId,
      required String courseType}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(courseId, serializer);
        sse_encode_String(courseType, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchAttendanceDetailConstMeta,
      argValues: [client, semesterId, courseId, courseType],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchAttendanceDetailConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_attendance_detail",
        argNames: ["client", "semesterId", "courseId", "courseType"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchBiometricData(
      {required VtopClient client, required String date}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(date, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 55, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchBiometricDataConstMeta,
      argValues: [client, date],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchBiometricDataConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_biometric_data",
        argNames: ["client", "date"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientFetchCookies(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchCookiesConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchCookiesConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_cookies",
        argNames: ["client"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchCourseDetail(
      {required VtopClient client,
      required String semesterId,
      required String erpId,
      required String classId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(erpId, serializer);
        sse_encode_String(classId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchCourseDetailConstMeta,
      argValues: [client, semesterId, erpId, classId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchCourseDetailConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_course_detail",
        argNames: ["client", "semesterId", "erpId", "classId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchCoursesForCoursePage(
      {required VtopClient client, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchCoursesForCoursePageConstMeta,
      argValues: [client, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchCoursesForCoursePageConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_courses_for_course_page",
        argNames: ["client", "semesterId"],
      );

  @override
  Future<String?> crateApiVtopGetClientFetchCsrfToken(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopGetClientFetchCsrfTokenConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchCsrfTokenConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_csrf_token",
        argNames: ["client"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchExamShedule(
      {required VtopClient client, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchExamSheduleConstMeta,
      argValues: [client, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchExamSheduleConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_exam_shedule",
        argNames: ["client", "semesterId"],
      );

  @override
  Future<FacultyDetails> crateApiVtopGetClientFetchFacultyData(
      {required VtopClient client, required String empId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(empId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_faculty_details,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchFacultyDataConstMeta,
      argValues: [client, empId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchFacultyDataConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_faculty_data",
        argNames: ["client", "empId"],
      );

  @override
  Future<GetFaculty> crateApiVtopGetClientFetchFacultySearch(
      {required VtopClient client, required String searchTerm}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(searchTerm, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_get_faculty,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchFacultySearchConstMeta,
      argValues: [client, searchTerm],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchFacultySearchConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_faculty_search",
        argNames: ["client", "searchTerm"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientFetchGeneralOutingPdf(
      {required VtopClient client, required String leaveId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(leaveId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchGeneralOutingPdfConstMeta,
      argValues: [client, leaveId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchGeneralOutingPdfConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_general_outing_pdf",
        argNames: ["client", "leaveId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchGeneralOutingReports(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchGeneralOutingReportsConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchGeneralOutingReportsConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_general_outing_reports",
        argNames: ["client"],
      );

  @override
  Future<GradeHistory> crateApiVtopGetClientFetchGradeHistory(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_grade_history,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchGradeHistoryConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchGradeHistoryConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_grade_history",
        argNames: ["client"],
      );

  @override
  Future<bool> crateApiVtopGetClientFetchIsAuth({required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopGetClientFetchIsAuthConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchIsAuthConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_is_auth",
        argNames: ["client"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchMarks(
      {required VtopClient client, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchMarksConstMeta,
      argValues: [client, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchMarksConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_marks",
        argNames: ["client", "semesterId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchPaymentReceipts(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchPaymentReceiptsConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchPaymentReceiptsConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_payment_receipts",
        argNames: ["client"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchPendingPayments(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchPendingPaymentsConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchPendingPaymentsConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_pending_payments",
        argNames: ["client"],
      );

  @override
  Future<SemesterData> crateApiVtopGetClientFetchSemesters(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_semester_data,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchSemestersConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchSemestersConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_semesters",
        argNames: ["client"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchSlotsForCoursePage(
      {required VtopClient client,
      required String semesterId,
      required String classId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        sse_encode_String(classId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchSlotsForCoursePageConstMeta,
      argValues: [client, semesterId, classId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchSlotsForCoursePageConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_slots_for_course_page",
        argNames: ["client", "semesterId", "classId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchStudentProfile(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchStudentProfileConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchStudentProfileConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_student_profile",
        argNames: ["client"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchTimetable(
      {required VtopClient client, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchTimetableConstMeta,
      argValues: [client, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchTimetableConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_timetable",
        argNames: ["client", "semesterId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchUsername(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 74, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopGetClientFetchUsernameConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchUsernameConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_username",
        argNames: ["client"],
      );

  @override
  Future<Uint8List> crateApiVtopGetClientFetchWeekendOutingPdf(
      {required VtopClient client, required String bookingId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(bookingId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchWeekendOutingPdfConstMeta,
      argValues: [client, bookingId],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchWeekendOutingPdfConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_weekend_outing_pdf",
        argNames: ["client", "bookingId"],
      );

  @override
  Future<String> crateApiVtopGetClientFetchWeekendOutingReports(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientFetchWeekendOutingReportsConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchWeekendOutingReportsConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_weekend_outing_reports",
        argNames: ["client"],
      );

  @override
  Future<(bool, String)> crateApiVtopGetClientFetchWifi(
      {required String username, required String password, required int i}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
        sse_encode_i_32(i, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_bool_string,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopGetClientFetchWifiConstMeta,
      argValues: [username, password, i],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientFetchWifiConstMeta =>
      const TaskConstMeta(
        debugName: "fetch_wifi",
        argNames: ["username", "password", "i"],
      );

  @override
  VtopClient crateApiVtopGetClientGetVtopClient(
      {required String username, required String password}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 78)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopGetClientGetVtopClientConstMeta,
      argValues: [username, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientGetVtopClientConstMeta =>
      const TaskConstMeta(
        debugName: "get_vtop_client",
        argNames: ["username", "password"],
      );

  @override
  String crateApiSimpleGreet({required String name}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(name, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleGreetConstMeta,
      argValues: [name],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleGreetConstMeta => const TaskConstMeta(
        debugName: "greet",
        argNames: ["name"],
      );

  @override
  Future<void> crateApiSimpleInitApp() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 80, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiSimpleInitAppConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiSimpleInitAppConstMeta => const TaskConstMeta(
        debugName: "init_app",
        argNames: [],
      );

  @override
  Future<String> crateApiVtopGetClientInitCoursePage(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientInitCoursePageConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientInitCoursePageConstMeta =>
      const TaskConstMeta(
        debugName: "init_course_page",
        argNames: ["client"],
      );

  @override
  Future<List<AttendanceRecord>>
      crateApiVtopParserAttendanceParserParseAttendance(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_attendance_record,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserAttendanceParserParseAttendanceConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserAttendanceParserParseAttendanceConstMeta =>
          const TaskConstMeta(
            debugName: "parse_attendance",
            argNames: ["html"],
          );

  @override
  Future<List<BiometricRecord>>
      crateApiVtopParserParseBiometricParseBiometricData(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_biometric_record,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserParseBiometricParseBiometricDataConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserParseBiometricParseBiometricDataConstMeta =>
          const TaskConstMeta(
            debugName: "parse_biometric_data",
            argNames: ["html"],
          );

  @override
  Future<CoursePageDetail>
      crateApiVtopParserCoursePageParserParseCourseDetailPage(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_course_page_detail,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserCoursePageParserParseCourseDetailPageConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserCoursePageParserParseCourseDetailPageConstMeta =>
          const TaskConstMeta(
            debugName: "parse_course_detail_page",
            argNames: ["html"],
          );

  @override
  Future<CoursesResponse>
      crateApiVtopParserCoursePageParserParseCoursesForCoursePage(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_courses_response,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserCoursePageParserParseCoursesForCoursePageConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserCoursePageParserParseCoursesForCoursePageConstMeta =>
          const TaskConstMeta(
            debugName: "parse_courses_for_course_page",
            argNames: ["html"],
          );

  @override
  Future<FacultyDetails> crateApiVtopParserFacultyParseaboutParseFacultyData(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_faculty_details,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserFacultyParseaboutParseFacultyDataConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserFacultyParseaboutParseFacultyDataConstMeta =>
          const TaskConstMeta(
            debugName: "parse_faculty_data",
            argNames: ["html"],
          );

  @override
  Future<GetFaculty> crateApiVtopParserFacultyParsesearchParseFacultySearch(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 87, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_get_faculty,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserFacultyParsesearchParseFacultySearchConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserFacultyParsesearchParseFacultySearchConstMeta =>
          const TaskConstMeta(
            debugName: "parse_faculty_search",
            argNames: ["html"],
          );

  @override
  Future<List<AttendanceDetailRecord>>
      crateApiVtopParserAttendanceParserParseFullAttendance(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 88, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_attendance_detail_record,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserAttendanceParserParseFullAttendanceConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserAttendanceParserParseFullAttendanceConstMeta =>
          const TaskConstMeta(
            debugName: "parse_full_attendance",
            argNames: ["html"],
          );

  @override
  Future<GradeHistory> crateApiVtopParserGradeHistoryParserParseGradeHistory(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 89, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_grade_history,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserGradeHistoryParserParseGradeHistoryConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserGradeHistoryParserParseGradeHistoryConstMeta =>
          const TaskConstMeta(
            debugName: "parse_grade_history",
            argNames: ["html"],
          );

  @override
  Future<List<GeneralOutingRecord>>
      crateApiVtopParserHostelGeneralOutingParserParseHostelLeave(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 90, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_general_outing_record,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserHostelGeneralOutingParserParseHostelLeaveConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserHostelGeneralOutingParserParseHostelLeaveConstMeta =>
          const TaskConstMeta(
            debugName: "parse_hostel_leave",
            argNames: ["html"],
          );

  @override
  Future<List<Marks>> crateApiVtopParserMarksParserParseMarks(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 91, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_marks,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserMarksParserParseMarksConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopParserMarksParserParseMarksConstMeta =>
      const TaskConstMeta(
        debugName: "parse_marks",
        argNames: ["html"],
      );

  @override
  Future<OutingInfo> crateApiVtopParserOutingFormParserParseOutingForm(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 92, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_outing_info,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopParserOutingFormParserParseOutingFormConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserOutingFormParserParseOutingFormConstMeta =>
          const TaskConstMeta(
            debugName: "parse_outing_form",
            argNames: ["html"],
          );

  @override
  Future<String> crateApiVtopParserOutingResponseParserParseOutingResponse(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 93, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserOutingResponseParserParseOutingResponseConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserOutingResponseParserParseOutingResponseConstMeta =>
          const TaskConstMeta(
            debugName: "parse_outing_response",
            argNames: ["html"],
          );

  @override
  Future<List<PaidPaymentReceipt>>
      crateApiVtopParserPaymentReceiptsParserParsePaymentReceipts(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 94, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_paid_payment_receipt,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserPaymentReceiptsParserParsePaymentReceiptsConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserPaymentReceiptsParserParsePaymentReceiptsConstMeta =>
          const TaskConstMeta(
            debugName: "parse_payment_receipts",
            argNames: ["html"],
          );

  @override
  Future<List<PendingPaymentReceipt>>
      crateApiVtopParserPendingPaymentsParserParsePendingPayments(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 95, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_pending_payment_receipt,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserPendingPaymentsParserParsePendingPaymentsConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserPendingPaymentsParserParsePendingPaymentsConstMeta =>
          const TaskConstMeta(
            debugName: "parse_pending_payments",
            argNames: ["html"],
          );

  @override
  Future<List<PerExamScheduleRecord>>
      crateApiVtopParserExamScheduleParserParseSchedule(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 96, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_per_exam_schedule_record,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserExamScheduleParserParseScheduleConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserExamScheduleParserParseScheduleConstMeta =>
          const TaskConstMeta(
            debugName: "parse_schedule",
            argNames: ["html"],
          );

  @override
  Future<SemesterData>
      crateApiVtopParserSemestedIdParserParseSemidFromTimetable(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 97, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_semester_data,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserSemestedIdParserParseSemidFromTimetableConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserSemestedIdParserParseSemidFromTimetableConstMeta =>
          const TaskConstMeta(
            debugName: "parse_semid_from_timetable",
            argNames: ["html"],
          );

  @override
  Future<SlotsResponse>
      crateApiVtopParserCoursePageParserParseSlotsForCoursePage(
          {required String html, required String semesterId}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        sse_encode_String(semesterId, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 98, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_slots_response,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserCoursePageParserParseSlotsForCoursePageConstMeta,
      argValues: [html, semesterId],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserCoursePageParserParseSlotsForCoursePageConstMeta =>
          const TaskConstMeta(
            debugName: "parse_slots_for_course_page",
            argNames: ["html", "semesterId"],
          );

  @override
  Future<StudentProfile> crateApiVtopParserProfileParserParseStudentProfile(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 99, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_student_profile,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserProfileParserParseStudentProfileConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserProfileParserParseStudentProfileConstMeta =>
          const TaskConstMeta(
            debugName: "parse_student_profile",
            argNames: ["html"],
          );

  @override
  Future<Timetable> crateApiVtopParserTimetableParserParseTimetable(
      {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 100, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_timetable,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopParserTimetableParserParseTimetableConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopParserTimetableParserParseTimetableConstMeta =>
      const TaskConstMeta(
        debugName: "parse_timetable",
        argNames: ["html"],
      );

  @override
  Future<List<WeekendOutingRecord>>
      crateApiVtopParserHostelWeekendOutingParserParseWeekendOuting(
          {required String html}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(html, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 101, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_weekend_outing_record,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiVtopParserHostelWeekendOutingParserParseWeekendOutingConstMeta,
      argValues: [html],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopParserHostelWeekendOutingParserParseWeekendOutingConstMeta =>
          const TaskConstMeta(
            debugName: "parse_weekend_outing",
            argNames: ["html"],
          );

  @override
  Future<VtopResultString> crateApiVtopCaptchaSolverSolveCaptcha(
      {required String captchaData}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(captchaData, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 102, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopCaptchaSolverSolveCaptchaConstMeta,
      argValues: [captchaData],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopCaptchaSolverSolveCaptchaConstMeta =>
      const TaskConstMeta(
        debugName: "solve_captcha",
        argNames: ["captchaData"],
      );

  @override
  Future<String> crateApiVtopGetClientStudentPaymentReceiptDownload(
      {required VtopClient client,
      required String receiptNo,
      required String applno}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(receiptNo, serializer);
        sse_encode_String(applno, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 103, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientStudentPaymentReceiptDownloadConstMeta,
      argValues: [client, receiptNo, applno],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiVtopGetClientStudentPaymentReceiptDownloadConstMeta =>
          const TaskConstMeta(
            debugName: "student_payment_receipt_download",
            argNames: ["client", "receiptNo", "applno"],
          );

  @override
  Future<String> crateApiVtopGetClientSubmitGeneralOutingForm(
      {required VtopClient client,
      required String outPlace,
      required String purposeOfVisit,
      required String outingDate,
      required String outTime,
      required String inDate,
      required String inTime}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(outPlace, serializer);
        sse_encode_String(purposeOfVisit, serializer);
        sse_encode_String(outingDate, serializer);
        sse_encode_String(outTime, serializer);
        sse_encode_String(inDate, serializer);
        sse_encode_String(inTime, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 104, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientSubmitGeneralOutingFormConstMeta,
      argValues: [
        client,
        outPlace,
        purposeOfVisit,
        outingDate,
        outTime,
        inDate,
        inTime
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientSubmitGeneralOutingFormConstMeta =>
      const TaskConstMeta(
        debugName: "submit_general_outing_form",
        argNames: [
          "client",
          "outPlace",
          "purposeOfVisit",
          "outingDate",
          "outTime",
          "inDate",
          "inTime"
        ],
      );

  @override
  Future<String> crateApiVtopGetClientSubmitWeekendOutingForm(
      {required VtopClient client,
      required String outPlace,
      required String purposeOfVisit,
      required String outingDate,
      required String outTime,
      required String contactNumber}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        sse_encode_String(outPlace, serializer);
        sse_encode_String(purposeOfVisit, serializer);
        sse_encode_String(outingDate, serializer);
        sse_encode_String(outTime, serializer);
        sse_encode_String(contactNumber, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 105, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientSubmitWeekendOutingFormConstMeta,
      argValues: [
        client,
        outPlace,
        purposeOfVisit,
        outingDate,
        outTime,
        contactNumber
      ],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientSubmitWeekendOutingFormConstMeta =>
      const TaskConstMeta(
        debugName: "submit_weekend_outing_form",
        argNames: [
          "client",
          "outPlace",
          "purposeOfVisit",
          "outingDate",
          "outTime",
          "contactNumber"
        ],
      );

  @override
  Future<(bool, String)> crateApiVtopWifiUniversityWifiLoginLogout(
      {required int i, required String username, required String password}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_i_32(i, serializer);
        sse_encode_String(username, serializer);
        sse_encode_String(password, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 106, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_record_bool_string,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopWifiUniversityWifiLoginLogoutConstMeta,
      argValues: [i, username, password],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopWifiUniversityWifiLoginLogoutConstMeta =>
      const TaskConstMeta(
        debugName: "university_wifi_login_logout",
        argNames: ["i", "username", "password"],
      );

  @override
  Future<void> crateApiVtopGetClientVtopClientLogin(
      {required VtopClient client}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
            client, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 107, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_vtop_error,
      ),
      constMeta: kCrateApiVtopGetClientVtopClientLoginConstMeta,
      argValues: [client],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopGetClientVtopClientLoginConstMeta =>
      const TaskConstMeta(
        debugName: "vtop_client_login",
        argNames: ["client"],
      );

  @override
  Future<VtopConfig> crateApiVtopVtopConfigVtopConfigDefault() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 108, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_vtop_config,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopConfigVtopConfigDefaultConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopConfigVtopConfigDefaultConstMeta =>
      const TaskConstMeta(
        debugName: "vtop_config_default",
        argNames: [],
      );

  @override
  Future<String> crateApiVtopVtopErrorsVtopErrorDebugMessage(
      {required VtopError that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_vtop_error(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 109, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopErrorsVtopErrorDebugMessageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopErrorsVtopErrorDebugMessageConstMeta =>
      const TaskConstMeta(
        debugName: "vtop_error_debug_message",
        argNames: ["that"],
      );

  @override
  Future<String> crateApiVtopVtopErrorsVtopErrorErrorType(
      {required VtopError that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_vtop_error(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 110, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopErrorsVtopErrorErrorTypeConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopErrorsVtopErrorErrorTypeConstMeta =>
      const TaskConstMeta(
        debugName: "vtop_error_error_type",
        argNames: ["that"],
      );

  @override
  Future<String> crateApiVtopVtopErrorsVtopErrorMessage(
      {required VtopError that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_vtop_error(that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 111, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiVtopVtopErrorsVtopErrorMessageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiVtopVtopErrorsVtopErrorMessageConstMeta =>
      const TaskConstMeta(
        debugName: "vtop_error_message",
        argNames: ["that"],
      );

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ArcJar => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ArcJar => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Response => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Response => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SessionManager => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SessionManager => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopClient => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopClient => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopClientBuilder => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopClientBuilder => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResult => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResult => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultCoursePageDetail => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultCoursePageDetail => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultCoursesResponse => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultCoursesResponse => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultFacultyDetails => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultFacultyDetails => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultGetFaculty => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultGetFaculty => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultGradeHistory => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultGradeHistory => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultSemesterData => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultSemesterData => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultSlotsResponse => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultSlotsResponse => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultString => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultString => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultStudentProfile => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultStudentProfile => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultTimetable => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultTimetable => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecAttendanceDetailRecord =>
          wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecAttendanceDetailRecord =>
          wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecAttendanceRecord => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecAttendanceRecord => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecBiometricRecord => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecBiometricRecord => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecGeneralOutingRecord => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecGeneralOutingRecord => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecMarks => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecMarks => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecPaidPaymentReceipt => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecPaidPaymentReceipt => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecPendingPaymentReceipt =>
          wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecPendingPaymentReceipt =>
          wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecPerExamScheduleRecord =>
          wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecPerExamScheduleRecord =>
          wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecWeekendOutingRecord => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecWeekendOutingRecord => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_VtopResultVecU8 => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_VtopResultVecU8 => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8;

  @protected
  ArcJar
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcJarImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SessionManager
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SessionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopClient
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopClientBuilder
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopClientBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResult
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultCoursePageDetail
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultCoursePageDetailImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultCoursesResponse
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultCoursesResponseImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultFacultyDetails
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultFacultyDetailsImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultGetFaculty
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultGetFacultyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultGradeHistory
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultGradeHistoryImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultSemesterData
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultSemesterDataImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultSlotsResponse
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultSlotsResponseImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultString
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultStringImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultStudentProfile
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultStudentProfileImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultTimetable
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultTimetableImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultVecAttendanceDetailRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecAttendanceDetailRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecAttendanceRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecAttendanceRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecBiometricRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecBiometricRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecGeneralOutingRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecGeneralOutingRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecMarks
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecMarksImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultVecPaidPaymentReceipt
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecPaidPaymentReceiptImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecPendingPaymentReceipt
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecPendingPaymentReceiptImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecPerExamScheduleRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecPerExamScheduleRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecWeekendOutingRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecWeekendOutingRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecU8
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecU8Impl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SessionManager
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SessionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopClient
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Response
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ResponseImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SessionManager
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SessionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopClient
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ArcJar
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ArcJarImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Response
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ResponseImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SessionManager
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SessionManagerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopClient
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopClientImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopClientBuilder
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopClientBuilderImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResult
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultCoursePageDetail
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultCoursePageDetailImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultCoursesResponse
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultCoursesResponseImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultFacultyDetails
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultFacultyDetailsImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultGetFaculty
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultGetFacultyImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultGradeHistory
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultGradeHistoryImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultSemesterData
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultSemesterDataImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultSlotsResponse
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultSlotsResponseImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultString
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultStringImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultStudentProfile
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultStudentProfileImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultTimetable
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultTimetableImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultVecAttendanceDetailRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecAttendanceDetailRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecAttendanceRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecAttendanceRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecBiometricRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecBiometricRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecGeneralOutingRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecGeneralOutingRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecMarks
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecMarksImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  VtopResultVecPaidPaymentReceipt
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecPaidPaymentReceiptImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecPendingPaymentReceipt
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecPendingPaymentReceiptImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecPerExamScheduleRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecPerExamScheduleRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecWeekendOutingRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecWeekendOutingRecordImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  VtopResultVecU8
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return VtopResultVecU8Impl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  AttendanceDetailRecord dco_decode_attendance_detail_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return AttendanceDetailRecord(
      serial: dco_decode_String(arr[0]),
      date: dco_decode_String(arr[1]),
      slot: dco_decode_String(arr[2]),
      dayTime: dco_decode_String(arr[3]),
      status: dco_decode_String(arr[4]),
      remark: dco_decode_String(arr[5]),
    );
  }

  @protected
  AttendanceRecord dco_decode_attendance_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return AttendanceRecord(
      classNumber: dco_decode_String(arr[0]),
      courseCode: dco_decode_String(arr[1]),
      courseName: dco_decode_String(arr[2]),
      courseType: dco_decode_String(arr[3]),
      courseTypeCode: dco_decode_String(arr[4]),
      courseSlot: dco_decode_String(arr[5]),
      faculty: dco_decode_String(arr[6]),
      attendedClasses: dco_decode_String(arr[7]),
      totalClasses: dco_decode_String(arr[8]),
      attendancePercentage: dco_decode_String(arr[9]),
      attendanceBetweenPercentage: dco_decode_String(arr[10]),
      debarStatus: dco_decode_String(arr[11]),
      courseId: dco_decode_String(arr[12]),
    );
  }

  @protected
  BiometricRecord dco_decode_biometric_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return BiometricRecord(
      serial: dco_decode_String(arr[0]),
      date: dco_decode_String(arr[1]),
      day: dco_decode_String(arr[2]),
      inTime: dco_decode_String(arr[3]),
      outTime: dco_decode_String(arr[4]),
      duration: dco_decode_String(arr[5]),
      location: dco_decode_String(arr[6]),
    );
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  VtopConfig dco_decode_box_autoadd_vtop_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_vtop_config(raw);
  }

  @protected
  VtopError dco_decode_box_autoadd_vtop_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_vtop_error(raw);
  }

  @protected
  CourseClassEntry dco_decode_course_class_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 10)
      throw Exception('unexpected arr length: expect 10 but see ${arr.length}');
    return CourseClassEntry(
      slNo: dco_decode_i_32(arr[0]),
      classGroup: dco_decode_String(arr[1]),
      courseCode: dco_decode_String(arr[2]),
      courseTitle: dco_decode_String(arr[3]),
      courseType: dco_decode_String(arr[4]),
      classId: dco_decode_String(arr[5]),
      slot: dco_decode_String(arr[6]),
      faculty: dco_decode_String(arr[7]),
      semesterId: dco_decode_String(arr[8]),
      erpId: dco_decode_String(arr[9]),
    );
  }

  @protected
  CourseInfo dco_decode_course_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return CourseInfo(
      classGroup: dco_decode_String(arr[0]),
      courseCode: dco_decode_String(arr[1]),
      courseTitle: dco_decode_String(arr[2]),
      courseType: dco_decode_String(arr[3]),
      classId: dco_decode_String(arr[4]),
      slot: dco_decode_String(arr[5]),
      faculty: dco_decode_String(arr[6]),
      courseId: dco_decode_String(arr[7]),
    );
  }

  @protected
  CourseOption dco_decode_course_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return CourseOption(
      value: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
      courseCode: dco_decode_String(arr[2]),
      courseTitle: dco_decode_String(arr[3]),
      courseType: dco_decode_String(arr[4]),
    );
  }

  @protected
  CoursePageDetail dco_decode_course_page_detail(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return CoursePageDetail(
      courseInfo: dco_decode_course_info(arr[0]),
      semesterId: dco_decode_String(arr[1]),
      downloadAllPath: dco_decode_opt_String(arr[2]),
      downloadGeneralMaterialsPath: dco_decode_opt_String(arr[3]),
      syllabusDownloadPath: dco_decode_opt_String(arr[4]),
      coursePlanDownloadPath: dco_decode_opt_String(arr[5]),
      lectures: dco_decode_list_lecture_entry(arr[6]),
    );
  }

  @protected
  CoursesResponse dco_decode_courses_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 1)
      throw Exception('unexpected arr length: expect 1 but see ${arr.length}');
    return CoursesResponse(
      courses: dco_decode_list_course_option(arr[0]),
    );
  }

  @protected
  ExamScheduleRecord dco_decode_exam_schedule_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return ExamScheduleRecord(
      serialNumber: dco_decode_String(arr[0]),
      slot: dco_decode_String(arr[1]),
      courseName: dco_decode_String(arr[2]),
      courseCode: dco_decode_String(arr[3]),
      courseType: dco_decode_String(arr[4]),
      courseId: dco_decode_String(arr[5]),
      examDate: dco_decode_String(arr[6]),
      examSession: dco_decode_String(arr[7]),
      reportingTime: dco_decode_String(arr[8]),
      examTime: dco_decode_String(arr[9]),
      venue: dco_decode_String(arr[10]),
      seatLocation: dco_decode_String(arr[11]),
      seatNumber: dco_decode_String(arr[12]),
    );
  }

  @protected
  FacultyDetails dco_decode_faculty_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return FacultyDetails(
      name: dco_decode_String(arr[0]),
      designation: dco_decode_String(arr[1]),
      department: dco_decode_String(arr[2]),
      schoolCentre: dco_decode_String(arr[3]),
      email: dco_decode_String(arr[4]),
      cabinNumber: dco_decode_String(arr[5]),
      officeHours: dco_decode_list_office_hour(arr[6]),
    );
  }

  @protected
  GeneralOutingRecord dco_decode_general_outing_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return GeneralOutingRecord(
      serial: dco_decode_String(arr[0]),
      registrationNumber: dco_decode_String(arr[1]),
      placeOfVisit: dco_decode_String(arr[2]),
      purposeOfVisit: dco_decode_String(arr[3]),
      fromDate: dco_decode_String(arr[4]),
      fromTime: dco_decode_String(arr[5]),
      toDate: dco_decode_String(arr[6]),
      toTime: dco_decode_String(arr[7]),
      status: dco_decode_String(arr[8]),
      canDownload: dco_decode_bool(arr[9]),
      leaveId: dco_decode_String(arr[10]),
    );
  }

  @protected
  GetFaculty dco_decode_get_faculty(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GetFaculty(
      facultyName: dco_decode_String(arr[0]),
      designation: dco_decode_String(arr[1]),
      schoolOrCentre: dco_decode_String(arr[2]),
      empId: dco_decode_String(arr[3]),
    );
  }

  @protected
  GradeCourseHistory dco_decode_grade_course_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return GradeCourseHistory(
      courseCode: dco_decode_String(arr[0]),
      courseTitle: dco_decode_String(arr[1]),
      courseType: dco_decode_String(arr[2]),
      credits: dco_decode_String(arr[3]),
      grade: dco_decode_String(arr[4]),
      examMonth: dco_decode_String(arr[5]),
      courseDistribution: dco_decode_String(arr[6]),
    );
  }

  @protected
  GradeHistory dco_decode_grade_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 4)
      throw Exception('unexpected arr length: expect 4 but see ${arr.length}');
    return GradeHistory(
      creditsRegistered: dco_decode_String(arr[0]),
      creditsEarned: dco_decode_String(arr[1]),
      cgpa: dco_decode_String(arr[2]),
      courses: dco_decode_list_grade_course_history(arr[3]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  LectureEntry dco_decode_lecture_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return LectureEntry(
      slNo: dco_decode_i_32(arr[0]),
      date: dco_decode_String(arr[1]),
      formattedDate: dco_decode_String(arr[2]),
      day: dco_decode_String(arr[3]),
      topic: dco_decode_String(arr[4]),
      referenceMaterials: dco_decode_list_reference_material(arr[5]),
    );
  }

  @protected
  List<AttendanceDetailRecord> dco_decode_list_attendance_detail_record(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_attendance_detail_record)
        .toList();
  }

  @protected
  List<AttendanceRecord> dco_decode_list_attendance_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_attendance_record).toList();
  }

  @protected
  List<BiometricRecord> dco_decode_list_biometric_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_biometric_record).toList();
  }

  @protected
  List<CourseClassEntry> dco_decode_list_course_class_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_course_class_entry).toList();
  }

  @protected
  List<CourseOption> dco_decode_list_course_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_course_option).toList();
  }

  @protected
  List<ExamScheduleRecord> dco_decode_list_exam_schedule_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_exam_schedule_record).toList();
  }

  @protected
  List<GeneralOutingRecord> dco_decode_list_general_outing_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_general_outing_record)
        .toList();
  }

  @protected
  List<GradeCourseHistory> dco_decode_list_grade_course_history(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_grade_course_history).toList();
  }

  @protected
  List<LectureEntry> dco_decode_list_lecture_entry(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_lecture_entry).toList();
  }

  @protected
  List<Marks> dco_decode_list_marks(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_marks).toList();
  }

  @protected
  List<MarksRecordEach> dco_decode_list_marks_record_each(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_marks_record_each).toList();
  }

  @protected
  List<OfficeHour> dco_decode_list_office_hour(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_office_hour).toList();
  }

  @protected
  List<PaidPaymentReceipt> dco_decode_list_paid_payment_receipt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_paid_payment_receipt).toList();
  }

  @protected
  List<PendingPaymentReceipt> dco_decode_list_pending_payment_receipt(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_pending_payment_receipt)
        .toList();
  }

  @protected
  List<PerExamScheduleRecord> dco_decode_list_per_exam_schedule_record(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_per_exam_schedule_record)
        .toList();
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<ReferenceMaterial> dco_decode_list_reference_material(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_reference_material).toList();
  }

  @protected
  List<SemesterInfo> dco_decode_list_semester_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_semester_info).toList();
  }

  @protected
  List<SlotOption> dco_decode_list_slot_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_slot_option).toList();
  }

  @protected
  List<TimetableClass> dco_decode_list_timetable_class(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_timetable_class).toList();
  }

  @protected
  List<WeekendOutingRecord> dco_decode_list_weekend_outing_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_weekend_outing_record)
        .toList();
  }

  @protected
  Marks dco_decode_marks(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return Marks(
      serialNumber: dco_decode_String(arr[0]),
      courseCode: dco_decode_String(arr[1]),
      courseTitle: dco_decode_String(arr[2]),
      courseType: dco_decode_String(arr[3]),
      faculty: dco_decode_String(arr[4]),
      slot: dco_decode_String(arr[5]),
      details: dco_decode_list_marks_record_each(arr[6]),
    );
  }

  @protected
  MarksRecordEach dco_decode_marks_record_each(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return MarksRecordEach(
      serialNumber: dco_decode_String(arr[0]),
      markTitle: dco_decode_String(arr[1]),
      maxMark: dco_decode_String(arr[2]),
      weightage: dco_decode_String(arr[3]),
      status: dco_decode_String(arr[4]),
      scoredMark: dco_decode_String(arr[5]),
      weightageMark: dco_decode_String(arr[6]),
      remark: dco_decode_String(arr[7]),
    );
  }

  @protected
  MentorDetails dco_decode_mentor_details(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return MentorDetails(
      facultyId: dco_decode_String(arr[0]),
      facultyName: dco_decode_String(arr[1]),
      facultyDesignation: dco_decode_String(arr[2]),
      school: dco_decode_String(arr[3]),
      cabin: dco_decode_String(arr[4]),
      facultyDepartment: dco_decode_String(arr[5]),
      facultyEmail: dco_decode_String(arr[6]),
      facultyIntercom: dco_decode_String(arr[7]),
      facultyMobileNumber: dco_decode_String(arr[8]),
    );
  }

  @protected
  OfficeHour dco_decode_office_hour(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return OfficeHour(
      day: dco_decode_String(arr[0]),
      timings: dco_decode_String(arr[1]),
    );
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  OutingInfo dco_decode_outing_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return OutingInfo(
      registrationNumber: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
      applicationNo: dco_decode_String(arr[2]),
      gender: dco_decode_String(arr[3]),
      hostelBlock: dco_decode_String(arr[4]),
      roomNumber: dco_decode_String(arr[5]),
      parentContactNumber: dco_decode_String(arr[6]),
    );
  }

  @protected
  PaidPaymentReceipt dco_decode_paid_payment_receipt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return PaidPaymentReceipt(
      receiptNumber: dco_decode_String(arr[0]),
      date: dco_decode_String(arr[1]),
      amount: dco_decode_String(arr[2]),
      campusCode: dco_decode_String(arr[3]),
      paymentStatus: dco_decode_String(arr[4]),
      receiptNo: dco_decode_String(arr[5]),
    );
  }

  @protected
  PendingPaymentReceipt dco_decode_pending_payment_receipt(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return PendingPaymentReceipt(
      sNo: dco_decode_String(arr[0]),
      fprefno: dco_decode_String(arr[1]),
      feesHeads: dco_decode_String(arr[2]),
      endDate: dco_decode_String(arr[3]),
      amount: dco_decode_String(arr[4]),
      fine: dco_decode_String(arr[5]),
      totalAmount: dco_decode_String(arr[6]),
      paymentStatus: dco_decode_String(arr[7]),
    );
  }

  @protected
  PerExamScheduleRecord dco_decode_per_exam_schedule_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PerExamScheduleRecord(
      subjects: dco_decode_list_exam_schedule_record(arr[0]),
      examType: dco_decode_String(arr[1]),
    );
  }

  @protected
  (bool, String) dco_decode_record_bool_string(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_bool(arr[0]),
      dco_decode_String(arr[1]),
    );
  }

  @protected
  ReferenceMaterial dco_decode_reference_material(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return ReferenceMaterial(
      label: dco_decode_String(arr[0]),
      downloadPath: dco_decode_String(arr[1]),
    );
  }

  @protected
  SemesterData dco_decode_semester_data(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SemesterData(
      semesters: dco_decode_list_semester_info(arr[0]),
      updateTime: dco_decode_u_64(arr[1]),
    );
  }

  @protected
  SemesterInfo dco_decode_semester_info(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SemesterInfo(
      id: dco_decode_String(arr[0]),
      name: dco_decode_String(arr[1]),
    );
  }

  @protected
  SlotOption dco_decode_slot_option(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SlotOption(
      value: dco_decode_String(arr[0]),
      label: dco_decode_String(arr[1]),
    );
  }

  @protected
  SlotsResponse dco_decode_slots_response(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return SlotsResponse(
      slots: dco_decode_list_slot_option(arr[0]),
      classEntries: dco_decode_list_course_class_entry(arr[1]),
    );
  }

  @protected
  StudentProfile dco_decode_student_profile(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 9)
      throw Exception('unexpected arr length: expect 9 but see ${arr.length}');
    return StudentProfile(
      applicationNumber: dco_decode_String(arr[0]),
      studentName: dco_decode_String(arr[1]),
      dob: dco_decode_String(arr[2]),
      gender: dco_decode_String(arr[3]),
      bloodGroup: dco_decode_String(arr[4]),
      email: dco_decode_String(arr[5]),
      base64Pfp: dco_decode_String(arr[6]),
      gradeHistory: dco_decode_grade_history(arr[7]),
      mentorDetails: dco_decode_mentor_details(arr[8]),
    );
  }

  @protected
  Timetable dco_decode_timetable(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 7)
      throw Exception('unexpected arr length: expect 7 but see ${arr.length}');
    return Timetable(
      monday: dco_decode_list_timetable_class(arr[0]),
      tuesday: dco_decode_list_timetable_class(arr[1]),
      wednesday: dco_decode_list_timetable_class(arr[2]),
      thursday: dco_decode_list_timetable_class(arr[3]),
      friday: dco_decode_list_timetable_class(arr[4]),
      saturday: dco_decode_list_timetable_class(arr[5]),
      sunday: dco_decode_list_timetable_class(arr[6]),
    );
  }

  @protected
  TimetableClass dco_decode_timetable_class(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return TimetableClass(
      startTime: dco_decode_String(arr[0]),
      endTime: dco_decode_String(arr[1]),
      courseName: dco_decode_String(arr[2]),
      slot: dco_decode_String(arr[3]),
      venue: dco_decode_String(arr[4]),
      faculty: dco_decode_String(arr[5]),
      courseCode: dco_decode_String(arr[6]),
      courseType: dco_decode_String(arr[7]),
    );
  }

  @protected
  BigInt dco_decode_u_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  VtopConfig dco_decode_vtop_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return VtopConfig(
      baseUrl: dco_decode_String(arr[0]),
      timeoutSeconds: dco_decode_u_64(arr[1]),
      userAgent: dco_decode_String(arr[2]),
    );
  }

  @protected
  VtopError dco_decode_vtop_error(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return VtopError_NetworkError();
      case 1:
        return VtopError_TimeoutError();
      case 2:
        return VtopError_SslError();
      case 3:
        return VtopError_DnsError();
      case 4:
        return VtopError_ConnectionRefused();
      case 5:
        return VtopError_VtopServerError();
      case 6:
        return VtopError_AuthenticationFailed(
          dco_decode_String(raw[1]),
        );
      case 7:
        return VtopError_RegistrationParsingError();
      case 8:
        return VtopError_InvalidCredentials();
      case 9:
        return VtopError_SessionExpired();
      case 10:
        return VtopError_ParseError(
          dco_decode_String(raw[1]),
        );
      case 11:
        return VtopError_ConfigurationError(
          dco_decode_String(raw[1]),
        );
      case 12:
        return VtopError_CaptchaRequired();
      case 13:
        return VtopError_InvalidResponse();
      case 14:
        return VtopError_ResponseReadError();
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  WeekendOutingRecord dco_decode_weekend_outing_record(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 13)
      throw Exception('unexpected arr length: expect 13 but see ${arr.length}');
    return WeekendOutingRecord(
      serial: dco_decode_String(arr[0]),
      registrationNumber: dco_decode_String(arr[1]),
      hostelBlock: dco_decode_String(arr[2]),
      roomNumber: dco_decode_String(arr[3]),
      placeOfVisit: dco_decode_String(arr[4]),
      purposeOfVisit: dco_decode_String(arr[5]),
      time: dco_decode_String(arr[6]),
      contactNumber: dco_decode_String(arr[7]),
      parentContactNumber: dco_decode_String(arr[8]),
      date: dco_decode_String(arr[9]),
      bookingId: dco_decode_String(arr[10]),
      status: dco_decode_String(arr[11]),
      canDownload: dco_decode_bool(arr[12]),
    );
  }

  @protected
  ArcJar
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcJarImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SessionManager
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SessionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopClient
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopClientBuilder
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopClientBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResult
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultCoursePageDetail
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultCoursePageDetailImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultCoursesResponse
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultCoursesResponseImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultFacultyDetails
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultFacultyDetailsImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultGetFaculty
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultGetFacultyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultGradeHistory
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultGradeHistoryImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultSemesterData
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultSemesterDataImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultSlotsResponse
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultSlotsResponseImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultString
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultStringImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultStudentProfile
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultStudentProfileImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultTimetable
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultTimetableImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecAttendanceDetailRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecAttendanceDetailRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecAttendanceRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecAttendanceRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecBiometricRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecBiometricRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecGeneralOutingRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecGeneralOutingRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecMarks
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecMarksImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecPaidPaymentReceipt
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecPaidPaymentReceiptImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecPendingPaymentReceipt
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecPendingPaymentReceiptImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecPerExamScheduleRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecPerExamScheduleRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecWeekendOutingRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecWeekendOutingRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecU8
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecU8Impl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SessionManager
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SessionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopClient
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Response
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ResponseImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SessionManager
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SessionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopClient
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ArcJar
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ArcJarImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Response
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ResponseImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SessionManager
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SessionManagerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopClient
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopClientImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopClientBuilder
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopClientBuilderImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResult
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultCoursePageDetail
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultCoursePageDetailImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultCoursesResponse
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultCoursesResponseImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultFacultyDetails
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultFacultyDetailsImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultGetFaculty
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultGetFacultyImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultGradeHistory
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultGradeHistoryImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultSemesterData
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultSemesterDataImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultSlotsResponse
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultSlotsResponseImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultString
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultStringImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultStudentProfile
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultStudentProfileImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultTimetable
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultTimetableImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecAttendanceDetailRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecAttendanceDetailRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecAttendanceRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecAttendanceRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecBiometricRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecBiometricRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecGeneralOutingRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecGeneralOutingRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecMarks
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecMarksImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecPaidPaymentReceipt
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecPaidPaymentReceiptImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecPendingPaymentReceipt
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecPendingPaymentReceiptImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecPerExamScheduleRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecPerExamScheduleRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecWeekendOutingRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecWeekendOutingRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  VtopResultVecU8
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return VtopResultVecU8Impl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  AttendanceDetailRecord sse_decode_attendance_detail_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serial = sse_decode_String(deserializer);
    var var_date = sse_decode_String(deserializer);
    var var_slot = sse_decode_String(deserializer);
    var var_dayTime = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_remark = sse_decode_String(deserializer);
    return AttendanceDetailRecord(
        serial: var_serial,
        date: var_date,
        slot: var_slot,
        dayTime: var_dayTime,
        status: var_status,
        remark: var_remark);
  }

  @protected
  AttendanceRecord sse_decode_attendance_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_classNumber = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseName = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    var var_courseTypeCode = sse_decode_String(deserializer);
    var var_courseSlot = sse_decode_String(deserializer);
    var var_faculty = sse_decode_String(deserializer);
    var var_attendedClasses = sse_decode_String(deserializer);
    var var_totalClasses = sse_decode_String(deserializer);
    var var_attendancePercentage = sse_decode_String(deserializer);
    var var_attendanceBetweenPercentage = sse_decode_String(deserializer);
    var var_debarStatus = sse_decode_String(deserializer);
    var var_courseId = sse_decode_String(deserializer);
    return AttendanceRecord(
        classNumber: var_classNumber,
        courseCode: var_courseCode,
        courseName: var_courseName,
        courseType: var_courseType,
        courseTypeCode: var_courseTypeCode,
        courseSlot: var_courseSlot,
        faculty: var_faculty,
        attendedClasses: var_attendedClasses,
        totalClasses: var_totalClasses,
        attendancePercentage: var_attendancePercentage,
        attendanceBetweenPercentage: var_attendanceBetweenPercentage,
        debarStatus: var_debarStatus,
        courseId: var_courseId);
  }

  @protected
  BiometricRecord sse_decode_biometric_record(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serial = sse_decode_String(deserializer);
    var var_date = sse_decode_String(deserializer);
    var var_day = sse_decode_String(deserializer);
    var var_inTime = sse_decode_String(deserializer);
    var var_outTime = sse_decode_String(deserializer);
    var var_duration = sse_decode_String(deserializer);
    var var_location = sse_decode_String(deserializer);
    return BiometricRecord(
        serial: var_serial,
        date: var_date,
        day: var_day,
        inTime: var_inTime,
        outTime: var_outTime,
        duration: var_duration,
        location: var_location);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  VtopConfig sse_decode_box_autoadd_vtop_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_vtop_config(deserializer));
  }

  @protected
  VtopError sse_decode_box_autoadd_vtop_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_vtop_error(deserializer));
  }

  @protected
  CourseClassEntry sse_decode_course_class_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_slNo = sse_decode_i_32(deserializer);
    var var_classGroup = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseTitle = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    var var_classId = sse_decode_String(deserializer);
    var var_slot = sse_decode_String(deserializer);
    var var_faculty = sse_decode_String(deserializer);
    var var_semesterId = sse_decode_String(deserializer);
    var var_erpId = sse_decode_String(deserializer);
    return CourseClassEntry(
        slNo: var_slNo,
        classGroup: var_classGroup,
        courseCode: var_courseCode,
        courseTitle: var_courseTitle,
        courseType: var_courseType,
        classId: var_classId,
        slot: var_slot,
        faculty: var_faculty,
        semesterId: var_semesterId,
        erpId: var_erpId);
  }

  @protected
  CourseInfo sse_decode_course_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_classGroup = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseTitle = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    var var_classId = sse_decode_String(deserializer);
    var var_slot = sse_decode_String(deserializer);
    var var_faculty = sse_decode_String(deserializer);
    var var_courseId = sse_decode_String(deserializer);
    return CourseInfo(
        classGroup: var_classGroup,
        courseCode: var_courseCode,
        courseTitle: var_courseTitle,
        courseType: var_courseType,
        classId: var_classId,
        slot: var_slot,
        faculty: var_faculty,
        courseId: var_courseId);
  }

  @protected
  CourseOption sse_decode_course_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseTitle = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    return CourseOption(
        value: var_value,
        label: var_label,
        courseCode: var_courseCode,
        courseTitle: var_courseTitle,
        courseType: var_courseType);
  }

  @protected
  CoursePageDetail sse_decode_course_page_detail(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_courseInfo = sse_decode_course_info(deserializer);
    var var_semesterId = sse_decode_String(deserializer);
    var var_downloadAllPath = sse_decode_opt_String(deserializer);
    var var_downloadGeneralMaterialsPath = sse_decode_opt_String(deserializer);
    var var_syllabusDownloadPath = sse_decode_opt_String(deserializer);
    var var_coursePlanDownloadPath = sse_decode_opt_String(deserializer);
    var var_lectures = sse_decode_list_lecture_entry(deserializer);
    return CoursePageDetail(
        courseInfo: var_courseInfo,
        semesterId: var_semesterId,
        downloadAllPath: var_downloadAllPath,
        downloadGeneralMaterialsPath: var_downloadGeneralMaterialsPath,
        syllabusDownloadPath: var_syllabusDownloadPath,
        coursePlanDownloadPath: var_coursePlanDownloadPath,
        lectures: var_lectures);
  }

  @protected
  CoursesResponse sse_decode_courses_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_courses = sse_decode_list_course_option(deserializer);
    return CoursesResponse(courses: var_courses);
  }

  @protected
  ExamScheduleRecord sse_decode_exam_schedule_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serialNumber = sse_decode_String(deserializer);
    var var_slot = sse_decode_String(deserializer);
    var var_courseName = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    var var_courseId = sse_decode_String(deserializer);
    var var_examDate = sse_decode_String(deserializer);
    var var_examSession = sse_decode_String(deserializer);
    var var_reportingTime = sse_decode_String(deserializer);
    var var_examTime = sse_decode_String(deserializer);
    var var_venue = sse_decode_String(deserializer);
    var var_seatLocation = sse_decode_String(deserializer);
    var var_seatNumber = sse_decode_String(deserializer);
    return ExamScheduleRecord(
        serialNumber: var_serialNumber,
        slot: var_slot,
        courseName: var_courseName,
        courseCode: var_courseCode,
        courseType: var_courseType,
        courseId: var_courseId,
        examDate: var_examDate,
        examSession: var_examSession,
        reportingTime: var_reportingTime,
        examTime: var_examTime,
        venue: var_venue,
        seatLocation: var_seatLocation,
        seatNumber: var_seatNumber);
  }

  @protected
  FacultyDetails sse_decode_faculty_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_name = sse_decode_String(deserializer);
    var var_designation = sse_decode_String(deserializer);
    var var_department = sse_decode_String(deserializer);
    var var_schoolCentre = sse_decode_String(deserializer);
    var var_email = sse_decode_String(deserializer);
    var var_cabinNumber = sse_decode_String(deserializer);
    var var_officeHours = sse_decode_list_office_hour(deserializer);
    return FacultyDetails(
        name: var_name,
        designation: var_designation,
        department: var_department,
        schoolCentre: var_schoolCentre,
        email: var_email,
        cabinNumber: var_cabinNumber,
        officeHours: var_officeHours);
  }

  @protected
  GeneralOutingRecord sse_decode_general_outing_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serial = sse_decode_String(deserializer);
    var var_registrationNumber = sse_decode_String(deserializer);
    var var_placeOfVisit = sse_decode_String(deserializer);
    var var_purposeOfVisit = sse_decode_String(deserializer);
    var var_fromDate = sse_decode_String(deserializer);
    var var_fromTime = sse_decode_String(deserializer);
    var var_toDate = sse_decode_String(deserializer);
    var var_toTime = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_canDownload = sse_decode_bool(deserializer);
    var var_leaveId = sse_decode_String(deserializer);
    return GeneralOutingRecord(
        serial: var_serial,
        registrationNumber: var_registrationNumber,
        placeOfVisit: var_placeOfVisit,
        purposeOfVisit: var_purposeOfVisit,
        fromDate: var_fromDate,
        fromTime: var_fromTime,
        toDate: var_toDate,
        toTime: var_toTime,
        status: var_status,
        canDownload: var_canDownload,
        leaveId: var_leaveId);
  }

  @protected
  GetFaculty sse_decode_get_faculty(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_facultyName = sse_decode_String(deserializer);
    var var_designation = sse_decode_String(deserializer);
    var var_schoolOrCentre = sse_decode_String(deserializer);
    var var_empId = sse_decode_String(deserializer);
    return GetFaculty(
        facultyName: var_facultyName,
        designation: var_designation,
        schoolOrCentre: var_schoolOrCentre,
        empId: var_empId);
  }

  @protected
  GradeCourseHistory sse_decode_grade_course_history(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseTitle = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    var var_credits = sse_decode_String(deserializer);
    var var_grade = sse_decode_String(deserializer);
    var var_examMonth = sse_decode_String(deserializer);
    var var_courseDistribution = sse_decode_String(deserializer);
    return GradeCourseHistory(
        courseCode: var_courseCode,
        courseTitle: var_courseTitle,
        courseType: var_courseType,
        credits: var_credits,
        grade: var_grade,
        examMonth: var_examMonth,
        courseDistribution: var_courseDistribution);
  }

  @protected
  GradeHistory sse_decode_grade_history(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_creditsRegistered = sse_decode_String(deserializer);
    var var_creditsEarned = sse_decode_String(deserializer);
    var var_cgpa = sse_decode_String(deserializer);
    var var_courses = sse_decode_list_grade_course_history(deserializer);
    return GradeHistory(
        creditsRegistered: var_creditsRegistered,
        creditsEarned: var_creditsEarned,
        cgpa: var_cgpa,
        courses: var_courses);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  LectureEntry sse_decode_lecture_entry(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_slNo = sse_decode_i_32(deserializer);
    var var_date = sse_decode_String(deserializer);
    var var_formattedDate = sse_decode_String(deserializer);
    var var_day = sse_decode_String(deserializer);
    var var_topic = sse_decode_String(deserializer);
    var var_referenceMaterials =
        sse_decode_list_reference_material(deserializer);
    return LectureEntry(
        slNo: var_slNo,
        date: var_date,
        formattedDate: var_formattedDate,
        day: var_day,
        topic: var_topic,
        referenceMaterials: var_referenceMaterials);
  }

  @protected
  List<AttendanceDetailRecord> sse_decode_list_attendance_detail_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AttendanceDetailRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_attendance_detail_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<AttendanceRecord> sse_decode_list_attendance_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <AttendanceRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_attendance_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<BiometricRecord> sse_decode_list_biometric_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <BiometricRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_biometric_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<CourseClassEntry> sse_decode_list_course_class_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CourseClassEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_course_class_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<CourseOption> sse_decode_list_course_option(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <CourseOption>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_course_option(deserializer));
    }
    return ans_;
  }

  @protected
  List<ExamScheduleRecord> sse_decode_list_exam_schedule_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ExamScheduleRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_exam_schedule_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<GeneralOutingRecord> sse_decode_list_general_outing_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GeneralOutingRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_general_outing_record(deserializer));
    }
    return ans_;
  }

  @protected
  List<GradeCourseHistory> sse_decode_list_grade_course_history(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <GradeCourseHistory>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_grade_course_history(deserializer));
    }
    return ans_;
  }

  @protected
  List<LectureEntry> sse_decode_list_lecture_entry(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <LectureEntry>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_lecture_entry(deserializer));
    }
    return ans_;
  }

  @protected
  List<Marks> sse_decode_list_marks(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Marks>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_marks(deserializer));
    }
    return ans_;
  }

  @protected
  List<MarksRecordEach> sse_decode_list_marks_record_each(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <MarksRecordEach>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_marks_record_each(deserializer));
    }
    return ans_;
  }

  @protected
  List<OfficeHour> sse_decode_list_office_hour(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <OfficeHour>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_office_hour(deserializer));
    }
    return ans_;
  }

  @protected
  List<PaidPaymentReceipt> sse_decode_list_paid_payment_receipt(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PaidPaymentReceipt>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_paid_payment_receipt(deserializer));
    }
    return ans_;
  }

  @protected
  List<PendingPaymentReceipt> sse_decode_list_pending_payment_receipt(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PendingPaymentReceipt>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_pending_payment_receipt(deserializer));
    }
    return ans_;
  }

  @protected
  List<PerExamScheduleRecord> sse_decode_list_per_exam_schedule_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PerExamScheduleRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_per_exam_schedule_record(deserializer));
    }
    return ans_;
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<ReferenceMaterial> sse_decode_list_reference_material(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <ReferenceMaterial>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_reference_material(deserializer));
    }
    return ans_;
  }

  @protected
  List<SemesterInfo> sse_decode_list_semester_info(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SemesterInfo>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_semester_info(deserializer));
    }
    return ans_;
  }

  @protected
  List<SlotOption> sse_decode_list_slot_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SlotOption>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_slot_option(deserializer));
    }
    return ans_;
  }

  @protected
  List<TimetableClass> sse_decode_list_timetable_class(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <TimetableClass>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_timetable_class(deserializer));
    }
    return ans_;
  }

  @protected
  List<WeekendOutingRecord> sse_decode_list_weekend_outing_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <WeekendOutingRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_weekend_outing_record(deserializer));
    }
    return ans_;
  }

  @protected
  Marks sse_decode_marks(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serialNumber = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseTitle = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    var var_faculty = sse_decode_String(deserializer);
    var var_slot = sse_decode_String(deserializer);
    var var_details = sse_decode_list_marks_record_each(deserializer);
    return Marks(
        serialNumber: var_serialNumber,
        courseCode: var_courseCode,
        courseTitle: var_courseTitle,
        courseType: var_courseType,
        faculty: var_faculty,
        slot: var_slot,
        details: var_details);
  }

  @protected
  MarksRecordEach sse_decode_marks_record_each(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serialNumber = sse_decode_String(deserializer);
    var var_markTitle = sse_decode_String(deserializer);
    var var_maxMark = sse_decode_String(deserializer);
    var var_weightage = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_scoredMark = sse_decode_String(deserializer);
    var var_weightageMark = sse_decode_String(deserializer);
    var var_remark = sse_decode_String(deserializer);
    return MarksRecordEach(
        serialNumber: var_serialNumber,
        markTitle: var_markTitle,
        maxMark: var_maxMark,
        weightage: var_weightage,
        status: var_status,
        scoredMark: var_scoredMark,
        weightageMark: var_weightageMark,
        remark: var_remark);
  }

  @protected
  MentorDetails sse_decode_mentor_details(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_facultyId = sse_decode_String(deserializer);
    var var_facultyName = sse_decode_String(deserializer);
    var var_facultyDesignation = sse_decode_String(deserializer);
    var var_school = sse_decode_String(deserializer);
    var var_cabin = sse_decode_String(deserializer);
    var var_facultyDepartment = sse_decode_String(deserializer);
    var var_facultyEmail = sse_decode_String(deserializer);
    var var_facultyIntercom = sse_decode_String(deserializer);
    var var_facultyMobileNumber = sse_decode_String(deserializer);
    return MentorDetails(
        facultyId: var_facultyId,
        facultyName: var_facultyName,
        facultyDesignation: var_facultyDesignation,
        school: var_school,
        cabin: var_cabin,
        facultyDepartment: var_facultyDepartment,
        facultyEmail: var_facultyEmail,
        facultyIntercom: var_facultyIntercom,
        facultyMobileNumber: var_facultyMobileNumber);
  }

  @protected
  OfficeHour sse_decode_office_hour(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_day = sse_decode_String(deserializer);
    var var_timings = sse_decode_String(deserializer);
    return OfficeHour(day: var_day, timings: var_timings);
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  OutingInfo sse_decode_outing_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_registrationNumber = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_applicationNo = sse_decode_String(deserializer);
    var var_gender = sse_decode_String(deserializer);
    var var_hostelBlock = sse_decode_String(deserializer);
    var var_roomNumber = sse_decode_String(deserializer);
    var var_parentContactNumber = sse_decode_String(deserializer);
    return OutingInfo(
        registrationNumber: var_registrationNumber,
        name: var_name,
        applicationNo: var_applicationNo,
        gender: var_gender,
        hostelBlock: var_hostelBlock,
        roomNumber: var_roomNumber,
        parentContactNumber: var_parentContactNumber);
  }

  @protected
  PaidPaymentReceipt sse_decode_paid_payment_receipt(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_receiptNumber = sse_decode_String(deserializer);
    var var_date = sse_decode_String(deserializer);
    var var_amount = sse_decode_String(deserializer);
    var var_campusCode = sse_decode_String(deserializer);
    var var_paymentStatus = sse_decode_String(deserializer);
    var var_receiptNo = sse_decode_String(deserializer);
    return PaidPaymentReceipt(
        receiptNumber: var_receiptNumber,
        date: var_date,
        amount: var_amount,
        campusCode: var_campusCode,
        paymentStatus: var_paymentStatus,
        receiptNo: var_receiptNo);
  }

  @protected
  PendingPaymentReceipt sse_decode_pending_payment_receipt(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_sNo = sse_decode_String(deserializer);
    var var_fprefno = sse_decode_String(deserializer);
    var var_feesHeads = sse_decode_String(deserializer);
    var var_endDate = sse_decode_String(deserializer);
    var var_amount = sse_decode_String(deserializer);
    var var_fine = sse_decode_String(deserializer);
    var var_totalAmount = sse_decode_String(deserializer);
    var var_paymentStatus = sse_decode_String(deserializer);
    return PendingPaymentReceipt(
        sNo: var_sNo,
        fprefno: var_fprefno,
        feesHeads: var_feesHeads,
        endDate: var_endDate,
        amount: var_amount,
        fine: var_fine,
        totalAmount: var_totalAmount,
        paymentStatus: var_paymentStatus);
  }

  @protected
  PerExamScheduleRecord sse_decode_per_exam_schedule_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_subjects = sse_decode_list_exam_schedule_record(deserializer);
    var var_examType = sse_decode_String(deserializer);
    return PerExamScheduleRecord(
        subjects: var_subjects, examType: var_examType);
  }

  @protected
  (bool, String) sse_decode_record_bool_string(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_bool(deserializer);
    var var_field1 = sse_decode_String(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  ReferenceMaterial sse_decode_reference_material(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_label = sse_decode_String(deserializer);
    var var_downloadPath = sse_decode_String(deserializer);
    return ReferenceMaterial(label: var_label, downloadPath: var_downloadPath);
  }

  @protected
  SemesterData sse_decode_semester_data(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_semesters = sse_decode_list_semester_info(deserializer);
    var var_updateTime = sse_decode_u_64(deserializer);
    return SemesterData(semesters: var_semesters, updateTime: var_updateTime);
  }

  @protected
  SemesterInfo sse_decode_semester_info(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_id = sse_decode_String(deserializer);
    var var_name = sse_decode_String(deserializer);
    return SemesterInfo(id: var_id, name: var_name);
  }

  @protected
  SlotOption sse_decode_slot_option(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_value = sse_decode_String(deserializer);
    var var_label = sse_decode_String(deserializer);
    return SlotOption(value: var_value, label: var_label);
  }

  @protected
  SlotsResponse sse_decode_slots_response(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_slots = sse_decode_list_slot_option(deserializer);
    var var_classEntries = sse_decode_list_course_class_entry(deserializer);
    return SlotsResponse(slots: var_slots, classEntries: var_classEntries);
  }

  @protected
  StudentProfile sse_decode_student_profile(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_applicationNumber = sse_decode_String(deserializer);
    var var_studentName = sse_decode_String(deserializer);
    var var_dob = sse_decode_String(deserializer);
    var var_gender = sse_decode_String(deserializer);
    var var_bloodGroup = sse_decode_String(deserializer);
    var var_email = sse_decode_String(deserializer);
    var var_base64Pfp = sse_decode_String(deserializer);
    var var_gradeHistory = sse_decode_grade_history(deserializer);
    var var_mentorDetails = sse_decode_mentor_details(deserializer);
    return StudentProfile(
        applicationNumber: var_applicationNumber,
        studentName: var_studentName,
        dob: var_dob,
        gender: var_gender,
        bloodGroup: var_bloodGroup,
        email: var_email,
        base64Pfp: var_base64Pfp,
        gradeHistory: var_gradeHistory,
        mentorDetails: var_mentorDetails);
  }

  @protected
  Timetable sse_decode_timetable(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_monday = sse_decode_list_timetable_class(deserializer);
    var var_tuesday = sse_decode_list_timetable_class(deserializer);
    var var_wednesday = sse_decode_list_timetable_class(deserializer);
    var var_thursday = sse_decode_list_timetable_class(deserializer);
    var var_friday = sse_decode_list_timetable_class(deserializer);
    var var_saturday = sse_decode_list_timetable_class(deserializer);
    var var_sunday = sse_decode_list_timetable_class(deserializer);
    return Timetable(
        monday: var_monday,
        tuesday: var_tuesday,
        wednesday: var_wednesday,
        thursday: var_thursday,
        friday: var_friday,
        saturday: var_saturday,
        sunday: var_sunday);
  }

  @protected
  TimetableClass sse_decode_timetable_class(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_startTime = sse_decode_String(deserializer);
    var var_endTime = sse_decode_String(deserializer);
    var var_courseName = sse_decode_String(deserializer);
    var var_slot = sse_decode_String(deserializer);
    var var_venue = sse_decode_String(deserializer);
    var var_faculty = sse_decode_String(deserializer);
    var var_courseCode = sse_decode_String(deserializer);
    var var_courseType = sse_decode_String(deserializer);
    return TimetableClass(
        startTime: var_startTime,
        endTime: var_endTime,
        courseName: var_courseName,
        slot: var_slot,
        venue: var_venue,
        faculty: var_faculty,
        courseCode: var_courseCode,
        courseType: var_courseType);
  }

  @protected
  BigInt sse_decode_u_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  VtopConfig sse_decode_vtop_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_baseUrl = sse_decode_String(deserializer);
    var var_timeoutSeconds = sse_decode_u_64(deserializer);
    var var_userAgent = sse_decode_String(deserializer);
    return VtopConfig(
        baseUrl: var_baseUrl,
        timeoutSeconds: var_timeoutSeconds,
        userAgent: var_userAgent);
  }

  @protected
  VtopError sse_decode_vtop_error(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        return VtopError_NetworkError();
      case 1:
        return VtopError_TimeoutError();
      case 2:
        return VtopError_SslError();
      case 3:
        return VtopError_DnsError();
      case 4:
        return VtopError_ConnectionRefused();
      case 5:
        return VtopError_VtopServerError();
      case 6:
        var var_field0 = sse_decode_String(deserializer);
        return VtopError_AuthenticationFailed(var_field0);
      case 7:
        return VtopError_RegistrationParsingError();
      case 8:
        return VtopError_InvalidCredentials();
      case 9:
        return VtopError_SessionExpired();
      case 10:
        var var_field0 = sse_decode_String(deserializer);
        return VtopError_ParseError(var_field0);
      case 11:
        var var_field0 = sse_decode_String(deserializer);
        return VtopError_ConfigurationError(var_field0);
      case 12:
        return VtopError_CaptchaRequired();
      case 13:
        return VtopError_InvalidResponse();
      case 14:
        return VtopError_ResponseReadError();
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  WeekendOutingRecord sse_decode_weekend_outing_record(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_serial = sse_decode_String(deserializer);
    var var_registrationNumber = sse_decode_String(deserializer);
    var var_hostelBlock = sse_decode_String(deserializer);
    var var_roomNumber = sse_decode_String(deserializer);
    var var_placeOfVisit = sse_decode_String(deserializer);
    var var_purposeOfVisit = sse_decode_String(deserializer);
    var var_time = sse_decode_String(deserializer);
    var var_contactNumber = sse_decode_String(deserializer);
    var var_parentContactNumber = sse_decode_String(deserializer);
    var var_date = sse_decode_String(deserializer);
    var var_bookingId = sse_decode_String(deserializer);
    var var_status = sse_decode_String(deserializer);
    var var_canDownload = sse_decode_bool(deserializer);
    return WeekendOutingRecord(
        serial: var_serial,
        registrationNumber: var_registrationNumber,
        hostelBlock: var_hostelBlock,
        roomNumber: var_roomNumber,
        placeOfVisit: var_placeOfVisit,
        purposeOfVisit: var_purposeOfVisit,
        time: var_time,
        contactNumber: var_contactNumber,
        parentContactNumber: var_parentContactNumber,
        date: var_date,
        bookingId: var_bookingId,
        status: var_status,
        canDownload: var_canDownload);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar(
          ArcJar self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcJarImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SessionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SessionManagerImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          VtopClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopClientImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
          VtopClientBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopClientBuilderImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult(
          VtopResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail(
          VtopResultCoursePageDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultCoursePageDetailImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse(
          VtopResultCoursesResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultCoursesResponseImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails(
          VtopResultFacultyDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultFacultyDetailsImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty(
          VtopResultGetFaculty self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultGetFacultyImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory(
          VtopResultGradeHistory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultGradeHistoryImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData(
          VtopResultSemesterData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultSemesterDataImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse(
          VtopResultSlotsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultSlotsResponseImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString(
          VtopResultString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultStringImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile(
          VtopResultStudentProfile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultStudentProfileImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable(
          VtopResultTimetable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultTimetableImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord(
          VtopResultVecAttendanceDetailRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecAttendanceDetailRecordImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord(
          VtopResultVecAttendanceRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecAttendanceRecordImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord(
          VtopResultVecBiometricRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecBiometricRecordImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord(
          VtopResultVecGeneralOutingRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecGeneralOutingRecordImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks(
          VtopResultVecMarks self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecMarksImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt(
          VtopResultVecPaidPaymentReceipt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecPaidPaymentReceiptImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt(
          VtopResultVecPendingPaymentReceipt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecPendingPaymentReceiptImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord(
          VtopResultVecPerExamScheduleRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecPerExamScheduleRecordImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord(
          VtopResultVecWeekendOutingRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecWeekendOutingRecordImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8(
          VtopResultVecU8 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecU8Impl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SessionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SessionManagerImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          VtopClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopClientImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
          Response self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ResponseImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SessionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SessionManagerImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          VtopClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopClientImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerArcJar(
          ArcJar self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ArcJarImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerResponse(
          Response self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ResponseImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSessionManager(
          SessionManager self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SessionManagerImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClient(
          VtopClient self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopClientImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopClientBuilder(
          VtopClientBuilder self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopClientBuilderImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResult(
          VtopResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursePageDetail(
          VtopResultCoursePageDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultCoursePageDetailImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultCoursesResponse(
          VtopResultCoursesResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultCoursesResponseImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultFacultyDetails(
          VtopResultFacultyDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultFacultyDetailsImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGetFaculty(
          VtopResultGetFaculty self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultGetFacultyImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultGradeHistory(
          VtopResultGradeHistory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultGradeHistoryImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSemesterData(
          VtopResultSemesterData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultSemesterDataImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultSlotsResponse(
          VtopResultSlotsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultSlotsResponseImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultString(
          VtopResultString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultStringImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultStudentProfile(
          VtopResultStudentProfile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultStudentProfileImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultTimetable(
          VtopResultTimetable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultTimetableImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceDetailRecord(
          VtopResultVecAttendanceDetailRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecAttendanceDetailRecordImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecAttendanceRecord(
          VtopResultVecAttendanceRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecAttendanceRecordImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecBiometricRecord(
          VtopResultVecBiometricRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecBiometricRecordImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecGeneralOutingRecord(
          VtopResultVecGeneralOutingRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecGeneralOutingRecordImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecMarks(
          VtopResultVecMarks self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecMarksImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPaidPaymentReceipt(
          VtopResultVecPaidPaymentReceipt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecPaidPaymentReceiptImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPendingPaymentReceipt(
          VtopResultVecPendingPaymentReceipt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecPendingPaymentReceiptImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecPerExamScheduleRecord(
          VtopResultVecPerExamScheduleRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecPerExamScheduleRecordImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecWeekendOutingRecord(
          VtopResultVecWeekendOutingRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecWeekendOutingRecordImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerVtopResultVecu8(
          VtopResultVecU8 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as VtopResultVecU8Impl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_attendance_detail_record(
      AttendanceDetailRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serial, serializer);
    sse_encode_String(self.date, serializer);
    sse_encode_String(self.slot, serializer);
    sse_encode_String(self.dayTime, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_String(self.remark, serializer);
  }

  @protected
  void sse_encode_attendance_record(
      AttendanceRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.classNumber, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseName, serializer);
    sse_encode_String(self.courseType, serializer);
    sse_encode_String(self.courseTypeCode, serializer);
    sse_encode_String(self.courseSlot, serializer);
    sse_encode_String(self.faculty, serializer);
    sse_encode_String(self.attendedClasses, serializer);
    sse_encode_String(self.totalClasses, serializer);
    sse_encode_String(self.attendancePercentage, serializer);
    sse_encode_String(self.attendanceBetweenPercentage, serializer);
    sse_encode_String(self.debarStatus, serializer);
    sse_encode_String(self.courseId, serializer);
  }

  @protected
  void sse_encode_biometric_record(
      BiometricRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serial, serializer);
    sse_encode_String(self.date, serializer);
    sse_encode_String(self.day, serializer);
    sse_encode_String(self.inTime, serializer);
    sse_encode_String(self.outTime, serializer);
    sse_encode_String(self.duration, serializer);
    sse_encode_String(self.location, serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void sse_encode_box_autoadd_vtop_config(
      VtopConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_vtop_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_vtop_error(
      VtopError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_vtop_error(self, serializer);
  }

  @protected
  void sse_encode_course_class_entry(
      CourseClassEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.slNo, serializer);
    sse_encode_String(self.classGroup, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseTitle, serializer);
    sse_encode_String(self.courseType, serializer);
    sse_encode_String(self.classId, serializer);
    sse_encode_String(self.slot, serializer);
    sse_encode_String(self.faculty, serializer);
    sse_encode_String(self.semesterId, serializer);
    sse_encode_String(self.erpId, serializer);
  }

  @protected
  void sse_encode_course_info(CourseInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.classGroup, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseTitle, serializer);
    sse_encode_String(self.courseType, serializer);
    sse_encode_String(self.classId, serializer);
    sse_encode_String(self.slot, serializer);
    sse_encode_String(self.faculty, serializer);
    sse_encode_String(self.courseId, serializer);
  }

  @protected
  void sse_encode_course_option(CourseOption self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseTitle, serializer);
    sse_encode_String(self.courseType, serializer);
  }

  @protected
  void sse_encode_course_page_detail(
      CoursePageDetail self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_course_info(self.courseInfo, serializer);
    sse_encode_String(self.semesterId, serializer);
    sse_encode_opt_String(self.downloadAllPath, serializer);
    sse_encode_opt_String(self.downloadGeneralMaterialsPath, serializer);
    sse_encode_opt_String(self.syllabusDownloadPath, serializer);
    sse_encode_opt_String(self.coursePlanDownloadPath, serializer);
    sse_encode_list_lecture_entry(self.lectures, serializer);
  }

  @protected
  void sse_encode_courses_response(
      CoursesResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_course_option(self.courses, serializer);
  }

  @protected
  void sse_encode_exam_schedule_record(
      ExamScheduleRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serialNumber, serializer);
    sse_encode_String(self.slot, serializer);
    sse_encode_String(self.courseName, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseType, serializer);
    sse_encode_String(self.courseId, serializer);
    sse_encode_String(self.examDate, serializer);
    sse_encode_String(self.examSession, serializer);
    sse_encode_String(self.reportingTime, serializer);
    sse_encode_String(self.examTime, serializer);
    sse_encode_String(self.venue, serializer);
    sse_encode_String(self.seatLocation, serializer);
    sse_encode_String(self.seatNumber, serializer);
  }

  @protected
  void sse_encode_faculty_details(
      FacultyDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.designation, serializer);
    sse_encode_String(self.department, serializer);
    sse_encode_String(self.schoolCentre, serializer);
    sse_encode_String(self.email, serializer);
    sse_encode_String(self.cabinNumber, serializer);
    sse_encode_list_office_hour(self.officeHours, serializer);
  }

  @protected
  void sse_encode_general_outing_record(
      GeneralOutingRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serial, serializer);
    sse_encode_String(self.registrationNumber, serializer);
    sse_encode_String(self.placeOfVisit, serializer);
    sse_encode_String(self.purposeOfVisit, serializer);
    sse_encode_String(self.fromDate, serializer);
    sse_encode_String(self.fromTime, serializer);
    sse_encode_String(self.toDate, serializer);
    sse_encode_String(self.toTime, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_bool(self.canDownload, serializer);
    sse_encode_String(self.leaveId, serializer);
  }

  @protected
  void sse_encode_get_faculty(GetFaculty self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.facultyName, serializer);
    sse_encode_String(self.designation, serializer);
    sse_encode_String(self.schoolOrCentre, serializer);
    sse_encode_String(self.empId, serializer);
  }

  @protected
  void sse_encode_grade_course_history(
      GradeCourseHistory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseTitle, serializer);
    sse_encode_String(self.courseType, serializer);
    sse_encode_String(self.credits, serializer);
    sse_encode_String(self.grade, serializer);
    sse_encode_String(self.examMonth, serializer);
    sse_encode_String(self.courseDistribution, serializer);
  }

  @protected
  void sse_encode_grade_history(GradeHistory self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.creditsRegistered, serializer);
    sse_encode_String(self.creditsEarned, serializer);
    sse_encode_String(self.cgpa, serializer);
    sse_encode_list_grade_course_history(self.courses, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_lecture_entry(LectureEntry self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.slNo, serializer);
    sse_encode_String(self.date, serializer);
    sse_encode_String(self.formattedDate, serializer);
    sse_encode_String(self.day, serializer);
    sse_encode_String(self.topic, serializer);
    sse_encode_list_reference_material(self.referenceMaterials, serializer);
  }

  @protected
  void sse_encode_list_attendance_detail_record(
      List<AttendanceDetailRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_attendance_detail_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_attendance_record(
      List<AttendanceRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_attendance_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_biometric_record(
      List<BiometricRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_biometric_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_course_class_entry(
      List<CourseClassEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_course_class_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_course_option(
      List<CourseOption> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_course_option(item, serializer);
    }
  }

  @protected
  void sse_encode_list_exam_schedule_record(
      List<ExamScheduleRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_exam_schedule_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_general_outing_record(
      List<GeneralOutingRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_general_outing_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_grade_course_history(
      List<GradeCourseHistory> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_grade_course_history(item, serializer);
    }
  }

  @protected
  void sse_encode_list_lecture_entry(
      List<LectureEntry> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_lecture_entry(item, serializer);
    }
  }

  @protected
  void sse_encode_list_marks(List<Marks> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_marks(item, serializer);
    }
  }

  @protected
  void sse_encode_list_marks_record_each(
      List<MarksRecordEach> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_marks_record_each(item, serializer);
    }
  }

  @protected
  void sse_encode_list_office_hour(
      List<OfficeHour> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_office_hour(item, serializer);
    }
  }

  @protected
  void sse_encode_list_paid_payment_receipt(
      List<PaidPaymentReceipt> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_paid_payment_receipt(item, serializer);
    }
  }

  @protected
  void sse_encode_list_pending_payment_receipt(
      List<PendingPaymentReceipt> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_pending_payment_receipt(item, serializer);
    }
  }

  @protected
  void sse_encode_list_per_exam_schedule_record(
      List<PerExamScheduleRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_per_exam_schedule_record(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_reference_material(
      List<ReferenceMaterial> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_reference_material(item, serializer);
    }
  }

  @protected
  void sse_encode_list_semester_info(
      List<SemesterInfo> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_semester_info(item, serializer);
    }
  }

  @protected
  void sse_encode_list_slot_option(
      List<SlotOption> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_slot_option(item, serializer);
    }
  }

  @protected
  void sse_encode_list_timetable_class(
      List<TimetableClass> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_timetable_class(item, serializer);
    }
  }

  @protected
  void sse_encode_list_weekend_outing_record(
      List<WeekendOutingRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_weekend_outing_record(item, serializer);
    }
  }

  @protected
  void sse_encode_marks(Marks self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serialNumber, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseTitle, serializer);
    sse_encode_String(self.courseType, serializer);
    sse_encode_String(self.faculty, serializer);
    sse_encode_String(self.slot, serializer);
    sse_encode_list_marks_record_each(self.details, serializer);
  }

  @protected
  void sse_encode_marks_record_each(
      MarksRecordEach self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serialNumber, serializer);
    sse_encode_String(self.markTitle, serializer);
    sse_encode_String(self.maxMark, serializer);
    sse_encode_String(self.weightage, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_String(self.scoredMark, serializer);
    sse_encode_String(self.weightageMark, serializer);
    sse_encode_String(self.remark, serializer);
  }

  @protected
  void sse_encode_mentor_details(MentorDetails self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.facultyId, serializer);
    sse_encode_String(self.facultyName, serializer);
    sse_encode_String(self.facultyDesignation, serializer);
    sse_encode_String(self.school, serializer);
    sse_encode_String(self.cabin, serializer);
    sse_encode_String(self.facultyDepartment, serializer);
    sse_encode_String(self.facultyEmail, serializer);
    sse_encode_String(self.facultyIntercom, serializer);
    sse_encode_String(self.facultyMobileNumber, serializer);
  }

  @protected
  void sse_encode_office_hour(OfficeHour self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.day, serializer);
    sse_encode_String(self.timings, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_outing_info(OutingInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.registrationNumber, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_String(self.applicationNo, serializer);
    sse_encode_String(self.gender, serializer);
    sse_encode_String(self.hostelBlock, serializer);
    sse_encode_String(self.roomNumber, serializer);
    sse_encode_String(self.parentContactNumber, serializer);
  }

  @protected
  void sse_encode_paid_payment_receipt(
      PaidPaymentReceipt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.receiptNumber, serializer);
    sse_encode_String(self.date, serializer);
    sse_encode_String(self.amount, serializer);
    sse_encode_String(self.campusCode, serializer);
    sse_encode_String(self.paymentStatus, serializer);
    sse_encode_String(self.receiptNo, serializer);
  }

  @protected
  void sse_encode_pending_payment_receipt(
      PendingPaymentReceipt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.sNo, serializer);
    sse_encode_String(self.fprefno, serializer);
    sse_encode_String(self.feesHeads, serializer);
    sse_encode_String(self.endDate, serializer);
    sse_encode_String(self.amount, serializer);
    sse_encode_String(self.fine, serializer);
    sse_encode_String(self.totalAmount, serializer);
    sse_encode_String(self.paymentStatus, serializer);
  }

  @protected
  void sse_encode_per_exam_schedule_record(
      PerExamScheduleRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_exam_schedule_record(self.subjects, serializer);
    sse_encode_String(self.examType, serializer);
  }

  @protected
  void sse_encode_record_bool_string(
      (bool, String) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self.$1, serializer);
    sse_encode_String(self.$2, serializer);
  }

  @protected
  void sse_encode_reference_material(
      ReferenceMaterial self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.label, serializer);
    sse_encode_String(self.downloadPath, serializer);
  }

  @protected
  void sse_encode_semester_data(SemesterData self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_semester_info(self.semesters, serializer);
    sse_encode_u_64(self.updateTime, serializer);
  }

  @protected
  void sse_encode_semester_info(SemesterInfo self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.id, serializer);
    sse_encode_String(self.name, serializer);
  }

  @protected
  void sse_encode_slot_option(SlotOption self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.value, serializer);
    sse_encode_String(self.label, serializer);
  }

  @protected
  void sse_encode_slots_response(SlotsResponse self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_slot_option(self.slots, serializer);
    sse_encode_list_course_class_entry(self.classEntries, serializer);
  }

  @protected
  void sse_encode_student_profile(
      StudentProfile self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.applicationNumber, serializer);
    sse_encode_String(self.studentName, serializer);
    sse_encode_String(self.dob, serializer);
    sse_encode_String(self.gender, serializer);
    sse_encode_String(self.bloodGroup, serializer);
    sse_encode_String(self.email, serializer);
    sse_encode_String(self.base64Pfp, serializer);
    sse_encode_grade_history(self.gradeHistory, serializer);
    sse_encode_mentor_details(self.mentorDetails, serializer);
  }

  @protected
  void sse_encode_timetable(Timetable self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_timetable_class(self.monday, serializer);
    sse_encode_list_timetable_class(self.tuesday, serializer);
    sse_encode_list_timetable_class(self.wednesday, serializer);
    sse_encode_list_timetable_class(self.thursday, serializer);
    sse_encode_list_timetable_class(self.friday, serializer);
    sse_encode_list_timetable_class(self.saturday, serializer);
    sse_encode_list_timetable_class(self.sunday, serializer);
  }

  @protected
  void sse_encode_timetable_class(
      TimetableClass self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.startTime, serializer);
    sse_encode_String(self.endTime, serializer);
    sse_encode_String(self.courseName, serializer);
    sse_encode_String(self.slot, serializer);
    sse_encode_String(self.venue, serializer);
    sse_encode_String(self.faculty, serializer);
    sse_encode_String(self.courseCode, serializer);
    sse_encode_String(self.courseType, serializer);
  }

  @protected
  void sse_encode_u_64(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }

  @protected
  void sse_encode_vtop_config(VtopConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.baseUrl, serializer);
    sse_encode_u_64(self.timeoutSeconds, serializer);
    sse_encode_String(self.userAgent, serializer);
  }

  @protected
  void sse_encode_vtop_error(VtopError self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case VtopError_NetworkError():
        sse_encode_i_32(0, serializer);
      case VtopError_TimeoutError():
        sse_encode_i_32(1, serializer);
      case VtopError_SslError():
        sse_encode_i_32(2, serializer);
      case VtopError_DnsError():
        sse_encode_i_32(3, serializer);
      case VtopError_ConnectionRefused():
        sse_encode_i_32(4, serializer);
      case VtopError_VtopServerError():
        sse_encode_i_32(5, serializer);
      case VtopError_AuthenticationFailed(field0: final field0):
        sse_encode_i_32(6, serializer);
        sse_encode_String(field0, serializer);
      case VtopError_RegistrationParsingError():
        sse_encode_i_32(7, serializer);
      case VtopError_InvalidCredentials():
        sse_encode_i_32(8, serializer);
      case VtopError_SessionExpired():
        sse_encode_i_32(9, serializer);
      case VtopError_ParseError(field0: final field0):
        sse_encode_i_32(10, serializer);
        sse_encode_String(field0, serializer);
      case VtopError_ConfigurationError(field0: final field0):
        sse_encode_i_32(11, serializer);
        sse_encode_String(field0, serializer);
      case VtopError_CaptchaRequired():
        sse_encode_i_32(12, serializer);
      case VtopError_InvalidResponse():
        sse_encode_i_32(13, serializer);
      case VtopError_ResponseReadError():
        sse_encode_i_32(14, serializer);
    }
  }

  @protected
  void sse_encode_weekend_outing_record(
      WeekendOutingRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.serial, serializer);
    sse_encode_String(self.registrationNumber, serializer);
    sse_encode_String(self.hostelBlock, serializer);
    sse_encode_String(self.roomNumber, serializer);
    sse_encode_String(self.placeOfVisit, serializer);
    sse_encode_String(self.purposeOfVisit, serializer);
    sse_encode_String(self.time, serializer);
    sse_encode_String(self.contactNumber, serializer);
    sse_encode_String(self.parentContactNumber, serializer);
    sse_encode_String(self.date, serializer);
    sse_encode_String(self.bookingId, serializer);
    sse_encode_String(self.status, serializer);
    sse_encode_bool(self.canDownload, serializer);
  }
}

@sealed
class ArcJarImpl extends RustOpaque implements ArcJar {
  // Not to be used by end users
  ArcJarImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ArcJarImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ArcJar,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcJar,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ArcJarPtr,
  );
}

@sealed
class ResponseImpl extends RustOpaque implements Response {
  // Not to be used by end users
  ResponseImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ResponseImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Response,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Response,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ResponsePtr,
  );
}

@sealed
class SessionManagerImpl extends RustOpaque implements SessionManager {
  // Not to be used by end users
  SessionManagerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SessionManagerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SessionManager,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SessionManager,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SessionManagerPtr,
  );

  /// Checks if a response indicates session expiration and handles it.
  ///
  /// # Arguments
  /// * `response` - The HTTP response to check
  ///
  /// # Returns
  /// Returns `Ok(())` if session is still valid, or `Err(VtopError::SessionExpired)` if expired
  Future<VtopResult> checkSessionExpiration({required Response response}) =>
      RustLib.instance.api
          .crateApiVtopSessionManagerSessionManagerCheckSessionExpiration(
              that: this, response: response);

  Future<void> clear() =>
      RustLib.instance.api.crateApiVtopSessionManagerSessionManagerClear(
        that: this,
      );

  Future<ArcJar> getCookieStore() => RustLib.instance.api
          .crateApiVtopSessionManagerSessionManagerGetCookieStore(
        that: this,
      );

  Future<String?> getCsrfToken() =>
      RustLib.instance.api.crateApiVtopSessionManagerSessionManagerGetCsrfToken(
        that: this,
      );

  Future<bool> isAuthenticated() => RustLib.instance.api
          .crateApiVtopSessionManagerSessionManagerIsAuthenticated(
        that: this,
      );

  Future<void> setAuthenticated({required bool authenticated}) =>
      RustLib.instance.api
          .crateApiVtopSessionManagerSessionManagerSetAuthenticated(
              that: this, authenticated: authenticated);

  Future<void> setCsrfFromExternal({required String token}) =>
      RustLib.instance.api
          .crateApiVtopSessionManagerSessionManagerSetCsrfFromExternal(
              that: this, token: token);

  Future<void> setCsrfToken({required String token}) =>
      RustLib.instance.api.crateApiVtopSessionManagerSessionManagerSetCsrfToken(
          that: this, token: token);
}

@sealed
class VtopClientBuilderImpl extends RustOpaque implements VtopClientBuilder {
  // Not to be used by end users
  VtopClientBuilderImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopClientBuilderImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VtopClientBuilder,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopClientBuilder,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopClientBuilderPtr,
  );

  Future<VtopClient> build(
          {required String username, required String password}) =>
      RustLib.instance.api.crateApiVtopVtopConfigVtopClientBuilderBuild(
          that: this, username: username, password: password);
}

@sealed
class VtopClientImpl extends RustOpaque implements VtopClient {
  // Not to be used by end users
  VtopClientImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopClientImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VtopClient,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopClient,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopClientPtr,
  );

  /// Deletes a general outing application from VTOP.
  ///
  /// Cancels/deletes a previously submitted general outing application using its Leave ID.
  /// This is useful when a student wants to cancel their outing request before it's processed
  /// or if they need to remove an outdated application.
  ///
  /// # Arguments
  ///
  /// * `leave_id` - The unique identifier for the general outing application (e.g., "L24044195432")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<String>` containing the server response message, which typically includes:
  /// - Success/failure status
  /// - Confirmation message about deletion
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The Leave ID doesn't exist or is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server rejects the deletion request (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Notes
  ///
  /// - Only the student who created the outing application can delete it
  /// - Applications that have already been approved may not be deletable
  /// - The Leave ID can be obtained from the general outing reports
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Delete a general outing application
  /// let response = client.delete_general_outing("L24044195432".to_string()).await?;
  ///
  /// if response.contains("success") || response.contains("deleted") {
  ///     println!("Outing application deleted successfully");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// ```
  /// # async fn example2(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Get outing reports and delete a specific one
  /// let reports = client.get_general_outing_reports().await?;
  /// if let Some(first_report) = reports.first() {
  ///     let leave_id = &first_report.leave_id;
  ///     let response = client.delete_general_outing(leave_id.clone()).await?;
  ///     println!("Deletion response: {}", response);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultString> deleteGeneralOuting({required String leaveId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientDeleteGeneralOuting(
          that: this, leaveId: leaveId);

  /// Deletes a weekend outing booking from VTOP.
  ///
  /// Cancels a previously submitted weekend outing booking. This can be used to remove
  /// a booking that is no longer needed or was created by mistake.
  ///
  /// # Arguments
  ///
  /// * `booking_id` - The booking ID of the weekend outing to delete (e.g., "W24044341477")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<String>` containing the server response message, which typically includes:
  /// - Success/failure status
  /// - Confirmation of deletion
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The booking ID is invalid or not found
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server rejects the request (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Delete a weekend outing booking
  /// let response = client.delete_weekend_outing(
  ///     "W24044341477".to_string(),
  /// ).await?;
  ///
  /// if response.contains("success") || response.contains("deleted") {
  ///     println!("Weekend outing deleted successfully");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultString> deleteWeekendOuting({required String bookingId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientDeleteWeekendOuting(
          that: this, bookingId: bookingId);

  /// Downloads all materials for a course as a ZIP archive.
  ///
  /// Downloads all reference materials attached to a course in a single ZIP file.
  /// The download path can be found in `CoursePageDetail.download_all_path`.
  ///
  /// # Arguments
  ///
  /// * `download_path` - The bulk download path (e.g., "academics/common/allCourseMeterialDownload/1/1/AP2025264/AP2025264000442")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<u8>>` containing the ZIP file as a byte vector.
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The download path is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let detail = client.get_course_detail("AP2025264", "70735", "AP2025264000442").await?;
  ///
  /// if let Some(download_path) = detail.download_all_path {
  ///     let bytes = client.download_all_course_materials(&download_path).await?;
  ///     std::fs::write("all_materials.zip", bytes)?;
  ///     println!("All materials downloaded");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecU8> downloadAllCourseMaterials(
          {required String downloadPath}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientDownloadAllCourseMaterials(
              that: this, downloadPath: downloadPath);

  /// Downloads course material (PDF, document, etc.) from the course page.
  ///
  /// Downloads a specific reference material attached to a lecture or
  /// general course materials. The download path should be obtained
  /// from `ReferenceMaterial.download_path` or the course page detail.
  ///
  /// # Arguments
  ///
  /// * `download_path` - The material download path (e.g., "downloadPdf/AP2025264/AP2025264000442/19/10-12-2025")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<u8>>` containing the file as a byte vector that can be:
  /// - Saved to disk
  /// - Displayed in a PDF viewer
  /// - Shared or printed
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The download path is invalid or the material doesn't exist
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Get course detail first
  /// let detail = client.get_course_detail("AP2025264", "70735", "AP2025264000442").await?;
  ///
  /// // Download a specific lecture material
  /// if let Some(lecture) = detail.lectures.first() {
  ///     if let Some(material) = lecture.reference_materials.first() {
  ///         let bytes = client.download_course_material(&material.download_path).await?;
  ///         std::fs::write("material.pdf", bytes)?;
  ///         println!("Material downloaded successfully");
  ///     }
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecU8> downloadCourseMaterial(
          {required String downloadPath}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientDownloadCourseMaterial(
              that: this, downloadPath: downloadPath);

  /// Downloads the course plan as an Excel file.
  ///
  /// Downloads the complete course plan including lecture schedule in Excel format.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The semester identifier
  /// * `class_id` - The class identifier
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<u8>>` containing the Excel file as bytes.
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The IDs are invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  Future<VtopResultVecU8> downloadCoursePlanExcel(
          {required String semesterId, required String classId}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientDownloadCoursePlanExcel(
              that: this, semesterId: semesterId, classId: classId);

  /// Downloads the course syllabus document.
  ///
  /// Downloads the official syllabus for the course. The download path
  /// can be found in `CoursePageDetail.syllabus_download_path`.
  ///
  /// # Arguments
  ///
  /// * `course_id` - The course ID (e.g., "AM_CSE2009_00110")
  /// * `course_type` - The course type (e.g., "ETH")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<u8>>` containing the syllabus document as bytes.
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The course ID or type is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  Future<VtopResultVecU8> downloadCourseSyllabus(
          {required String courseId, required String courseType}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientDownloadCourseSyllabus(
              that: this, courseId: courseId, courseType: courseType);

  /// Downloads the official payment receipt document from VTOP.
  ///
  /// Retrieves the HTML or PDF content of a payment receipt for a specific transaction.
  /// This receipt serves as proof of payment for tuition fees, hostel fees, exam fees,
  /// or other university charges. The receipt contains transaction details, payment
  /// method, timestamps, and official university acknowledgment.
  ///
  /// # Arguments
  ///
  /// * `receipt_no` - The receipt number/ID of the payment transaction (obtained from `get_payment_receipts()`)
  /// * `applno` - The application number associated with the payment transaction
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<String>` containing the receipt document as HTML/text that includes:
  /// - Receipt number and date
  /// - Student registration number and name
  /// - Payment description/purpose
  /// - Amount paid and payment method
  /// - Transaction ID and bank details
  /// - Official acknowledgment/stamp
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided receipt number or application number is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // First get the list of receipts
  /// let receipts = client.get_payment_receipts().await?;
  ///
  /// // Download a specific receipt
  /// if let Some(receipt) = receipts.first() {
  ///     let receipt_html = client.download_payment_receipt(
  ///         receipt.receipt_no.clone(),
  ///         receipt.applno.clone()
  ///     ).await?;
  ///
  ///     // Save to file or display
  ///     std::fs::write("payment_receipt.html", receipt_html)?;
  ///     println!("Receipt downloaded successfully");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultString> downloadPaymentReceipt(
          {required String receiptNo, required String applno}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientDownloadPaymentReceipt(
              that: this, receiptNo: receiptNo, applno: applno);

  /// Retrieves the attendance summary for all courses in a specific semester.
  ///
  /// Fetches attendance statistics for each registered course including total classes,
  /// attended classes, and attendance percentage. This provides an overview of attendance
  /// across all courses without detailed session-by-session breakdown.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The unique identifier for the semester (obtained from `get_semesters()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<AttendanceRecord>>` containing a vector of attendance records where each record includes:
  /// - Course code and name
  /// - Course type (Theory/Lab/Tutorial)
  /// - Total number of classes conducted
  /// - Number of classes attended
  /// - Attendance percentage
  /// - Faculty name
  /// - Slot information
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided semester ID is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let attendance = client.get_attendance("AP2425SEM1234").await?;
  /// for record in attendance {
  ///     println!("{}: {}% ({}/{})",
  ///         record.course_name,
  ///         record.percentage,
  ///         record.attended,
  ///         record.total
  ///     );
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecAttendanceRecord> getAttendance(
          {required String semesterId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetAttendance(
          that: this, semesterId: semesterId);

  /// Retrieves detailed attendance records for a specific course.
  ///
  /// Fetches session-by-session attendance details for a particular course, including
  /// individual class dates, timings, attendance status, and any remarks. This provides
  /// a granular view of attendance beyond the summary statistics.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The unique identifier for the semester
  /// * `course_id` - The course code (e.g., "CSE1001", "MAT2001")
  /// * `course_type` - The type of course ("Theory", "Lab", "Embedded Theory", "Embedded Lab", etc.)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<AttendanceDetailRecord>>` containing detailed attendance information:
  /// - Date and time of each class session
  /// - Attendance status (Present/Absent/OD/Medical Leave)
  /// - Session number and slot information
  /// - Faculty who took the class
  /// - Any remarks or notes for the session
  /// - Topic covered in the session
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided semester ID, course ID, or course type is invalid
  /// - The student is not registered for the specified course
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let details = client.get_attendance_detail(
  ///     "AP2425SEM1234",
  ///     "CSE1001",
  ///     "Theory"
  /// ).await?;
  ///
  /// for session in details {
  ///     println!("Date: {}, Status: {}, Topic: {}",
  ///         session.date,
  ///         session.status,
  ///         session.topic
  ///     );
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecAttendanceDetailRecord> getAttendanceDetail(
          {required String semesterId,
          required String courseId,
          required String courseType}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetAttendanceDetail(
          that: this,
          semesterId: semesterId,
          courseId: courseId,
          courseType: courseType);

  /// Retrieves biometric attendance records for a specific date.
  ///
  /// Fetches the student's biometric entry/exit records from the campus biometric system
  /// for the specified date. This includes timestamps of when the student entered and
  /// exited the campus premises, useful for tracking attendance and time spent on campus.
  ///
  /// # Arguments
  ///
  /// * `date` - The date for which to fetch biometric records, in the format "DD-MMM-YYYY"
  ///            (e.g., "15-Oct-2024")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<BiometricRecord>>` containing a list of biometric records:
  /// - Entry timestamp (date and time of campus entry)
  /// - Exit timestamp (date and time of campus exit)
  /// - Location/gate information
  /// - Duration spent on campus
  /// - Any remarks or notes
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided date format is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let records = client.get_biometric_data("15-Oct-2024".to_string()).await?;
  /// for record in records {
  ///     println!("Entry: {}, Exit: {}",
  ///         record.entry_time,
  ///         record.exit_time
  ///     );
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecBiometricRecord> getBiometricData(
          {required String date}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetBiometricData(
          that: this, date: date);

  /// Retrieves the current session's cookies as a byte vector.
  ///
  /// Returns an error if the session is not authenticated.
  ///
  /// # Returns
  /// A vector of bytes representing the session cookies, or an error if the session has expired.
  ///
  /// # Examples
  ///
  /// ```
  /// let cookies = client.get_cookie().await?;
  /// assert!(!cookies.is_empty());
  /// ```
  Future<VtopResultVecU8> getCookie() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetCookie(
        that: this,
      );

  /// Retrieves the detailed course page with all lectures and materials.
  ///
  /// Fetches the complete course page including lecture schedule, topics,
  /// and downloadable reference materials for each lecture.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The semester identifier (e.g., "AP2025264")
  /// * `erp_id` - The faculty ERP ID (e.g., "70735")
  /// * `class_id` - The class identifier (e.g., "AP2025264000442")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<CoursePageDetail>` containing:
  /// - Course information (code, title, faculty, slot, etc.)
  /// - Download paths for syllabus and all materials
  /// - List of lectures with their topics and attached materials
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided IDs are invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let detail = client.get_course_detail("AP2025264", "70735", "AP2025264000442").await?;
  /// println!("Course: {} - {}", detail.course_info.course_code, detail.course_info.course_title);
  /// for lecture in detail.lectures {
  ///     println!("  {} - {}", lecture.date, lecture.topic);
  ///     for material in lecture.reference_materials {
  ///         println!("    Material: {}", material.label);
  ///     }
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultCoursePageDetail> getCourseDetail(
          {required String semesterId,
          required String erpId,
          required String classId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetCourseDetail(
          that: this, semesterId: semesterId, erpId: erpId, classId: classId);

  /// Retrieves the list of courses available for a specific semester.
  ///
  /// Fetches all courses registered by the student for the given semester that
  /// have course page content (materials, lectures, etc.).
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The semester identifier (e.g., "AP2025264")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<CoursesResponse>` containing:
  /// - List of courses with their IDs, codes, titles, and types
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The semester ID is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let courses = client.get_courses_for_course_page("AP2025264").await?;
  /// for course in courses.courses {
  ///     println!("{} - {} ({})", course.course_code, course.course_title, course.course_type);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultCoursesResponse> getCoursesForCoursePage(
          {required String semesterId}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientGetCoursesForCoursePage(
              that: this, semesterId: semesterId);

  /// Retrieves the examination schedule for all courses in a specific semester.
  ///
  /// Fetches comprehensive exam schedule information including exam dates, timings,
  /// venues, exam types, and seating arrangements for all registered courses in the semester.
  /// This helps students plan and prepare for upcoming examinations.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The unique identifier for the semester (obtained from `get_semesters()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<PerExamScheduleRecord>>` containing exam details for each course:
  /// - Course code and name
  /// - Exam type (CAT-1, CAT-2, FAT, Mid-term, End-term, etc.)
  /// - Exam date and time
  /// - Duration of the examination
  /// - Exam venue and room number
  /// - Seating arrangement details (row, column, seat number)
  /// - Slot information
  /// - Any special instructions or requirements
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided semester ID is invalid
  /// - Exam schedule has not been published yet
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let schedule = client.get_exam_schedule("AP2425SEM1234").await?;
  /// for exam in schedule {
  ///     println!("{} - {} on {} at {}",
  ///         exam.course_name,
  ///         exam.exam_type,
  ///         exam.exam_date,
  ///         exam.exam_time
  ///     );
  ///     println!("Venue: {}, Seat: {}", exam.venue, exam.seat_number);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecPerExamScheduleRecord> getExamSchedule(
          {required String semesterId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetExamSchedule(
          that: this, semesterId: semesterId);

  /// Retrieves detailed information about a specific faculty member.
  ///
  /// Fetches comprehensive profile information for a faculty member identified by their
  /// employee ID. This includes personal details, academic qualifications, research interests,
  /// contact information, and professional experience.
  ///
  /// # Arguments
  ///
  /// * `emp_id` - The employee ID of the faculty member (obtained from `get_faculty_search()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<FacultyDetails>` containing comprehensive information:
  /// - Full name and employee ID
  /// - Department and school affiliation
  /// - Designation and position
  /// - Email address and phone number
  /// - Office location and cabin number
  /// - Educational qualifications
  /// - Research areas and interests
  /// - Publications and achievements
  /// - Consultation hours/availability
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided employee ID is invalid or not found
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // First search for faculty
  /// let search_results = client.get_faculty_search("Sharma".to_string()).await?;
  ///
  /// // Then get detailed information
  /// if let Some(faculty) = search_results.faculty_list.first() {
  ///     let details = client.get_faculty_data(faculty.emp_id.clone()).await?;
  ///     println!("Name: {}", details.name);
  ///     println!("Email: {}", details.email);
  ///     println!("Department: {}", details.department);
  ///     println!("Cabin: {}", details.cabin_number);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultFacultyDetails> getFacultyData({required String empId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetFacultyData(
          that: this, empId: empId);

  /// Searches for faculty members by name or employee ID.
  ///
  /// Performs a search query against the VTOP faculty database to find faculty members
  /// matching the provided search term. Returns a list of matching faculty with basic
  /// information like name, employee ID, department, and designation.
  ///
  /// # Arguments
  ///
  /// * `search_term` - The search query string (can be partial name, full name, or employee ID)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<GetFaculty>` containing:
  /// - List of matching faculty members
  /// - Each entry includes: employee ID, name, department, designation, school
  /// - Search metadata (total results, query info)
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The search term is empty or invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Search by name
  /// let results = client.get_faculty_search("Sharma".to_string()).await?;
  /// for faculty in results.faculty_list {
  ///     println!("{} - {} ({})",
  ///         faculty.name,
  ///         faculty.designation,
  ///         faculty.department
  ///     );
  /// }
  ///
  /// // Search by employee ID
  /// let results = client.get_faculty_search("EMP123".to_string()).await?;
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultGetFaculty> getFacultySearch({required String searchTerm}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetFacultySearch(
          that: this, searchTerm: searchTerm);

  /// Downloads the PDF pass for a specific general outing application.
  ///
  /// Retrieves the official leave pass document in PDF format for an approved general
  /// outing. This pass typically needs to be shown to hostel security when leaving campus.
  /// The PDF contains student details, outing information, and approval signatures.
  ///
  /// # Arguments
  ///
  /// * `leave_id` - The unique identifier of the leave application (obtained from `get_general_outing_reports()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<u8>>` containing the PDF file as a byte vector that can be:
  /// - Saved to disk as a `.pdf` file
  /// - Displayed in a PDF viewer
  /// - Shared or printed
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided leave ID is invalid or not found
  /// - The leave application is not yet approved (may return empty/error)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // First get the outing records
  /// let outings = client.get_general_outing_reports().await?;
  ///
  /// // Download PDF for an approved outing
  /// if let Some(outing) = outings.iter().find(|o| o.status == "Approved") {
  ///     let pdf_bytes = client.get_general_outing_pdf(outing.leave_id.clone()).await?;
  ///
  ///     // Save to file
  ///     std::fs::write("outing_pass.pdf", pdf_bytes)?;
  ///     println!("PDF saved successfully");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecU8> getGeneralOutingPdf({required String leaveId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetGeneralOutingPdf(
          that: this, leaveId: leaveId);

  /// Retrieves the student's general outing (day leave) records from VTOP.
  ///
  /// Fetches a list of all general outing applications submitted by the student, including
  /// both approved and pending requests. General outings are typically used for day trips
  /// or short leaves that don't require overnight permission.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<GeneralOutingRecord>>` containing:
  /// - Leave application ID (for PDF download)
  /// - Purpose of visit/outing
  /// - Destination/place of visit
  /// - Outing date and time
  /// - Return date and time
  /// - Application status (pending/approved/rejected)
  /// - Parent contact number
  /// - Application submission timestamp
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let outings = client.get_general_outing_reports().await?;
  /// for outing in outings {
  ///     println!("Destination: {}", outing.destination);
  ///     println!("Date: {}", outing.outing_date);
  ///     println!("Status: {}", outing.status);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecGeneralOutingRecord> getGeneralOutingReports() =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientGetGeneralOutingReports(
        that: this,
      );

  /// Retrieves the complete academic grade history for the authenticated student.
  ///
  /// Fetches comprehensive grade records spanning all completed semesters, including course-wise
  /// grades, credit information, GPA/CGPA calculations, and academic performance trends. This data
  /// is essential for tracking academic progress, calculating overall performance, and preparing
  /// transcripts or academic reports.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<GradeHistory>` containing:
  /// - **Overall Performance**:
  ///   - Cumulative GPA (CGPA)
  ///   - Total credits earned
  ///   - Total credits attempted
  ///   - Overall grade point average
  /// - **Semester-wise Records**: For each semester:
  ///   - Semester name and academic year
  ///   - Semester GPA (SGPA)
  ///   - Credits earned in that semester
  ///   - List of courses taken
  /// - **Course-wise Details**: For each course:
  ///   - Course code and name
  ///   - Course type (Theory/Lab/Project)
  ///   - Credits
  ///   - Grade obtained (A, B+, C, etc.)
  ///   - Grade points
  ///   - Internal marks and external marks
  ///   - Total marks
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - The response cannot be parsed (malformed HTML/data)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let grade_history = client.get_grade_history().await?;
  ///
  /// // Display overall performance
  /// println!("CGPA: {:.2}", grade_history.cgpa);
  /// println!("Total Credits: {}", grade_history.total_credits);
  ///
  /// // Display semester-wise performance
  /// for semester in &grade_history.semesters {
  ///     println!("\n{} - SGPA: {:.2}", semester.name, semester.sgpa);
  ///
  ///     for course in &semester.courses {
  ///         println!("  {} | {} | Grade: {} | Credits: {}",
  ///             course.code,
  ///             course.name,
  ///             course.grade,
  ///             course.credits
  ///         );
  ///     }
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// ```
  /// # async fn example2(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Calculate semester-wise GPA trend
  /// let grade_history = client.get_grade_history().await?;
  ///
  /// println!("Academic Performance Trend:");
  /// for semester in &grade_history.semesters {
  ///     let bar = "".repeat((semester.sgpa * 10.0) as usize);
  ///     println!("{:20} | {:.2} {}", semester.name, semester.sgpa, bar);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultGradeHistory> getGradeHistory() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetGradeHistory(
        that: this,
      );

  /// Downloads the PDF pass for a specific weekend outing booking.
  ///
  /// Retrieves the official weekend outing pass document in PDF format. This pass must be
  /// shown to hostel security when leaving for a weekend outing and upon return. The PDF
  /// includes student details, outing dates, emergency contacts, and approval information.
  ///
  /// # Arguments
  ///
  /// * `booking_id` - The unique identifier of the weekend outing booking (obtained from `get_weekend_outing_reports()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<u8>>` containing the PDF file as a byte vector that can be:
  /// - Saved to disk as a `.pdf` file
  /// - Displayed in a PDF viewer
  /// - Shared with parents or guardians
  /// - Shown to security personnel
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided booking ID is invalid or not found
  /// - The booking is not yet confirmed (may return empty/error)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Get weekend outing records
  /// let outings = client.get_weekend_outing_reports().await?;
  ///
  /// // Download PDF for a confirmed booking
  /// if let Some(outing) = outings.iter().find(|o| o.status == "Confirmed") {
  ///     let pdf_bytes = client.get_hostel_outing_pdf(outing.booking_id.clone()).await?;
  ///
  ///     // Save to file
  ///     std::fs::write("weekend_pass.pdf", pdf_bytes)?;
  ///     println!("Weekend pass downloaded");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecU8> getHostelOutingPdf({required String bookingId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetHostelOutingPdf(
          that: this, bookingId: bookingId);

  /// Retrieves marks and assessment scores for all courses in a specific semester.
  ///
  /// Fetches detailed marks information including CAT (Continuous Assessment Test) scores,
  /// assignment marks, quiz scores, and final assessment marks for each registered course.
  /// This provides comprehensive academic performance data for the semester.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The unique identifier for the semester (obtained from `get_semesters()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<Marks>>` containing marks information for each course:
  /// - Course code, name, and credits
  /// - CAT 1, CAT 2, and other periodic test scores
  /// - Assignment and quiz marks
  /// - Digital assignment scores
  /// - Final assessment marks
  /// - Total marks obtained and maximum marks
  /// - Grade status and evaluation status
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided semester ID is invalid
  /// - Marks have not been published for the semester
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let marks = client.get_marks("AP2425SEM1234").await?;
  /// for course_marks in marks {
  ///     println!("{}: Total {}/{}",
  ///         course_marks.course_name,
  ///         course_marks.total_marks_obtained,
  ///         course_marks.total_marks_maximum
  ///     );
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecMarks> getMarks({required String semesterId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetMarks(
          that: this, semesterId: semesterId);

  /// Retrieves the complete history of payment receipts for the authenticated student.
  ///
  /// Fetches a list of all successful payment transactions made through VTOP. This includes
  /// tuition fees, hostel fees, examination fees, library fines, and other university charges.
  /// Each receipt record contains transaction details that can be used to download the full
  /// official receipt document.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<PaidPaymentReceipt>>` containing a list of payment receipts with:
  /// - Receipt number (for downloading the full receipt)
  /// - Application number (transaction reference)
  /// - Payment description/category (e.g., "Tuition Fee - Semester 5")
  /// - Amount paid
  /// - Payment date and timestamp
  /// - Payment mode (Online/Card/Net Banking)
  /// - Transaction status (Paid/Success)
  /// - Semester and academic year
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let receipts = client.get_payment_receipts().await?;
  ///
  /// // Display payment history
  /// for receipt in &receipts {
  ///     println!("Receipt: {} | Amount: {} | Date: {}",
  ///         receipt.receipt_no,
  ///         receipt.amount,
  ///         receipt.payment_date
  ///     );
  /// }
  ///
  /// // Calculate total paid
  /// let total: f64 = receipts.iter()
  ///     .map(|r| r.amount)
  ///     .sum();
  /// println!("Total paid: {}", total);
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecPaidPaymentReceipt> getPaymentReceipts() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetPaymentReceipts(
        that: this,
      );

  /// Retrieves all pending payment obligations for the authenticated student.
  ///
  /// Fetches a list of unpaid fees and charges that are due or overdue. This includes
  /// upcoming semester fees, hostel charges, library fines, examination fees, and other
  /// university dues. Students should regularly check this to avoid late payment penalties
  /// and ensure they can access academic services (registration, exams, results).
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<PendingPaymentReceipt>>` containing pending payments with:
  /// - Payment description/category (e.g., "Semester Fee - Fall 2024")
  /// - Amount due
  /// - Due date/deadline
  /// - Payment status (Pending/Overdue)
  /// - Payment link or transaction ID (for online payment)
  /// - Semester and academic year
  /// - Late fee penalty (if applicable)
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let pending = client.get_pending_payment().await?;
  ///
  /// if pending.is_empty() {
  ///     println!("No pending payments - all clear!");
  /// } else {
  ///     println!("You have {} pending payment(s):", pending.len());
  ///
  ///     for payment in &pending {
  ///         println!("- {} | Amount: {} | Due: {}",
  ///             payment.description,
  ///             payment.amount,
  ///             payment.due_date
  ///         );
  ///     }
  ///
  ///     // Calculate total due
  ///     let total_due: f64 = pending.iter()
  ///         .map(|p| p.amount)
  ///         .sum();
  ///     println!("\nTotal amount due: {}", total_due);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// ```
  /// # async fn example2(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Check for overdue payments
  /// let pending = client.get_pending_payment().await?;
  /// let overdue: Vec<_> = pending.iter()
  ///     .filter(|p| p.status == "Overdue")
  ///     .collect();
  ///
  /// if !overdue.is_empty() {
  ///     println!("URGENT: {} overdue payment(s) require immediate attention!", overdue.len());
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecPendingPaymentReceipt> getPendingPayment() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetPendingPayment(
        that: this,
      );

  /// Retrieves the list of available semesters for the authenticated student.
  ///
  /// This method fetches all semester data including semester IDs, names, and other metadata
  /// that can be used to query semester-specific information like timetables, attendance, and marks.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<SemesterData>` containing:
  /// - A list of all available semesters with their IDs and descriptions
  /// - Current semester information
  /// - Semester enrollment details
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The CSRF token is missing or invalid (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let semester_data = client.get_semesters().await?;
  /// for semester in semester_data.semesters {
  ///     println!("Semester: {} (ID: {})", semester.name, semester.id);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultSemesterData> getSemesters() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetSemesters(
        that: this,
      );

  /// Retrieves slot and class information for a specific course.
  ///
  /// Fetches available time slots and class entries for a selected course,
  /// including faculty information and class IDs needed for viewing course details.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The semester identifier (e.g., "AP2025264")
  /// * `class_id` - The course class identifier (e.g., "AP2025264000394")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<SlotsResponse>` containing:
  /// - List of available slots
  /// - List of class entries with faculty and timing information
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The semester ID or class ID is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let slots = client.get_slots_for_course_page("AP2025264", "AP2025264000394").await?;
  /// for entry in slots.class_entries {
  ///     println!("{} - {} - {}", entry.course_code, entry.slot, entry.faculty);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultSlotsResponse> getSlotsForCoursePage(
          {required String semesterId, required String classId}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientGetSlotsForCoursePage(
              that: this, semesterId: semesterId, classId: classId);

  /// Retrieves the comprehensive student profile with all personal and academic information.
  ///
  /// Fetches the complete student profile containing personal details, contact information,
  /// program enrollment data, and full academic grade history. This is a combined operation
  /// that makes multiple requests to gather all profile information into a single unified
  /// data structure. This method is ideal for profile pages, academic dashboards, or
  /// generating comprehensive student reports.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<StudentProfile>` containing:
  /// - **Personal Information**:
  ///   - Full name and registration number
  ///   - Date of birth and gender
  ///   - Blood group
  ///   - Profile photograph URL
  ///   - Category (General/OBC/SC/ST)
  /// - **Contact Details**:
  ///   - Personal email and university email
  ///   - Mobile number
  ///   - Current address and permanent address
  ///   - Parent/guardian contact information
  /// - **Academic Information**:
  ///   - Program name (B.Tech, M.Tech, etc.)
  ///   - Branch/specialization
  ///   - School/department
  ///   - Current semester
  ///   - Admission year and category
  ///   - Student type (Regular/Lateral)
  /// - **Grade History**: Complete academic performance (see `get_grade_history()` for details)
  ///   - CGPA and semester-wise SGPA
  ///   - Course-wise grades and credits
  /// - **Additional Details**:
  ///   - Proctor/mentor information
  ///   - Hostel information (if applicable)
  ///   - Library card details
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails during profile or grade history fetch (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - The response data cannot be parsed correctly
  /// - Session expires during either request and re-authentication fails
  ///
  /// # Notes
  ///
  /// This method makes two internal API calls:
  /// 1. Fetches basic profile information
  /// 2. Fetches grade history (via `get_grade_history()`)
  ///
  /// Both are combined into a single `StudentProfile` object for convenience.
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let profile = client.get_student_profile().await?;
  ///
  /// // Display student information
  /// println!("=== Student Profile ===");
  /// println!("Name: {}", profile.student_name);
  /// println!("Reg No: {}", profile.registration_number);
  /// println!("Program: {} - {}", profile.program, profile.branch);
  /// println!("Email: {}", profile.email);
  /// println!("Phone: {}", profile.phone);
  /// println!("\nAcademic Performance:");
  /// println!("CGPA: {:.2}", profile.grade_history.cgpa);
  /// println!("Credits Earned: {}", profile.grade_history.total_credits);
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// ```
  /// # async fn example2(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Generate a student report card
  /// let profile = client.get_student_profile().await?;
  ///
  /// println!("");
  /// println!("       STUDENT ACADEMIC REPORT         ");
  /// println!("");
  /// println!(" Name: {:<31} ", profile.student_name);
  /// println!(" Reg:  {:<31} ", profile.registration_number);
  /// println!(" Program: {:<28} ", profile.program);
  /// println!(" CGPA: {:<31.2} ", profile.grade_history.cgpa);
  /// println!("");
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultStudentProfile> getStudentProfile() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetStudentProfile(
        that: this,
      );

  /// Retrieves the complete timetable for a specific semester.
  ///
  /// Fetches the weekly class schedule including course details, timings, venues,
  /// faculty information, and class types (Theory/Lab/Tutorial) for the specified semester.
  ///
  /// # Arguments
  ///
  /// * `semester_id` - The unique identifier for the semester (obtained from `get_semesters()`)
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Timetable>` containing:
  /// - Weekly schedule organized by days and time slots
  /// - Course codes, names, and types
  /// - Venue and room information
  /// - Faculty names assigned to each course
  /// - Slot timings and duration
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - The provided semester ID is invalid or not found
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let semesters = client.get_semesters().await?;
  /// if let Some(current_sem) = semesters.semesters.first() {
  ///     let timetable = client.get_timetable(&current_sem.id).await?;
  ///     println!("Monday classes: {:?}", timetable.monday);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultTimetable> getTimetable({required String semesterId}) =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientGetTimetable(
          that: this, semesterId: semesterId);

  /// Retrieves the student's weekend outing records from VTOP.
  ///
  /// Fetches a list of all weekend outing bookings made by the student, including past and
  /// upcoming weekend leaves. Weekend outings typically require advance booking and cover
  /// Friday evening through Sunday night or longer holiday periods.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<Vec<WeekendOutingRecord>>` containing:
  /// - Booking ID (for PDF download)
  /// - Outing type (weekend/holiday)
  /// - Check-out date and time
  /// - Expected check-in date and time
  /// - Destination information
  /// - Booking status (confirmed/pending/cancelled)
  /// - Emergency contact details
  /// - Mode of transport
  /// - Booking timestamp
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// let weekend_outings = client.get_weekend_outing_reports().await?;
  /// for outing in weekend_outings {
  ///     println!("Checkout: {}", outing.checkout_date);
  ///     println!("Expected return: {}", outing.checkin_date);
  ///     println!("Status: {}", outing.status);
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultVecWeekendOutingRecord> getWeekendOutingReports() =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientGetWeekendOutingReports(
        that: this,
      );

  /// Initializes the Course Page view and returns semester options.
  ///
  /// This method navigates to the Course Page section and returns the initial page.
  /// This should be called first before accessing course page functionality.
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<String>` containing the HTML of the course page.
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server returns an error response (`VtopError::VtopServerError`)
  Future<VtopResultString> initCoursePage() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientInitCoursePage(
        that: this,
      );

  /// Checks if the client has an active authenticated session.
  ///
  /// This method verifies whether the current session is authenticated and valid
  /// for making API requests to VTOP. It should be called before attempting
  /// operations that require authentication.
  ///
  /// # Returns
  ///
  /// Returns `true` if the session is authenticated and active, `false` otherwise.
  ///
  /// # Examples
  ///
  /// ```
  /// # fn example(client: &mut VtopClient) {
  /// if client.is_authenticated() {
  ///     println!("Session is active");
  ///     // Proceed with authenticated operations
  /// } else {
  ///     println!("Need to login first");
  ///     // Call client.login() before making requests
  /// }
  /// # }
  /// ```
  Future<bool> isAuthenticated() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientIsAuthenticated(
        that: this,
      );

  /// Authenticates the user with the VTOP system using provided credentials.
  ///
  /// This method performs a complete login flow including:
  /// 1. Loading the initial login page to obtain session cookies
  /// 2. Extracting CSRF tokens for security
  /// 3. Solving CAPTCHA challenges automatically
  /// 4. Submitting credentials and validating the response
  /// 5. Establishing an authenticated session
  ///
  /// The method automatically retries up to 4 times if CAPTCHA verification fails,
  /// loading a fresh CAPTCHA image for each attempt.
  ///
  /// # Returns
  ///
  /// Returns `Ok(())` if authentication succeeds and a valid session is established.
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The username or password is incorrect (`VtopError::InvalidCredentials`)
  /// - CAPTCHA solving fails repeatedly (`VtopError::CaptchaRequired` or `VtopError::AuthenticationFailed`)
  /// - Maximum login attempts (4) are exceeded (`VtopError::AuthenticationFailed`)
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server is unavailable (`VtopError::VtopServerError`)
  /// - CSRF token extraction fails (`VtopError::ParseError`)
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
  /// use lib_vtop::{VtopClient, VtopConfig, SessionManager};
  ///
  /// let config = VtopConfig::default();
  /// let session = SessionManager::new();
  /// let mut client = VtopClient::with_config(
  ///     config,
  ///     session,
  ///     "21BCE1234".to_string(),
  ///     "password123".to_string()
  /// );
  ///
  /// match client.login().await {
  ///     Ok(_) => println!("Login successful!"),
  ///     Err(e) => eprintln!("Login failed: {:?}", e),
  /// }
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// # Notes
  ///
  /// - This method must be called before any other API methods that require authentication
  /// - The session remains valid until explicitly logged out or until VTOP server invalidates it
  /// - Failed login attempts may temporarily lock the account after multiple failures
  Future<VtopResult> login() =>
      RustLib.instance.api.crateApiVtopVtopClientVtopClientLogin(
        that: this,
      );

  /// Submits a new general outing application form to VTOP.
  ///
  /// Creates a new day outing application with the provided details. The application will
  /// be submitted to the hostel administration for approval. This method follows a two-step
  /// process: first fetching the student's pre-filled form data, then submitting the complete
  /// form with both user-provided and auto-populated information.
  ///
  /// # Arguments
  ///
  /// * `out_place` - Destination or place to be visited
  /// * `purpose_of_visit` - The reason for the outing (e.g., "Medical appointment", "Shopping", "Family visit")
  /// * `outing_date` - The date of the outing in format "DD-MMM-YYYY" (e.g., "15-Mar-2024")
  /// * `out_time` - Expected departure time in "HH:MM" format (e.g., "14:00")
  /// * `in_date` - Expected return date in format "DD-MMM-YYYY" (e.g., "15-Mar-2024")
  /// * `in_time` - Expected return time in "HH:MM" format (e.g., "18:00")
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<String>` containing the server response message, which typically includes:
  /// - Success/failure status
  /// - Application reference number
  /// - Approval status or pending message
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Failed to fetch student form information (`VtopError::ParseError`)
  /// - The outing date/time format is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server rejects the application (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Notes
  ///
  /// This method automatically fetches student information (name, gender, hostel block,
  /// room number, parent contact) from VTOP before submitting the form. Times are split
  /// into hours and minutes for the VTOP API.
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Submit a general outing application for medical appointment
  /// let response = client.submit_general_outing_form(
  ///     "Apollo Hospital, Vijayawada".to_string(),
  ///     "Medical checkup".to_string(),
  ///     "15-Mar-2024".to_string(),
  ///     "14:00".to_string(),
  ///     "15-Mar-2024".to_string(),
  ///     "18:00".to_string(),
  /// ).await?;
  ///
  /// println!("Application response: {}", response);
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// ```
  /// # async fn example2(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Submit for evening shopping trip
  /// let response = client.submit_general_outing_form(
  ///     "PVP Mall, Vijayawada".to_string(),
  ///     "Shopping for essentials".to_string(),
  ///     "20-Mar-2024".to_string(),
  ///     "16:00".to_string(),
  ///     "20-Mar-2024".to_string(),
  ///     "21:00".to_string(),
  /// ).await?;
  ///
  /// if response.contains("success") || response.contains("submitted") {
  ///     println!("Outing application submitted successfully");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultString> submitGeneralOutingForm(
          {required String outPlace,
          required String purposeOfVisit,
          required String outingDate,
          required String outTime,
          required String inDate,
          required String inTime}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientSubmitGeneralOutingForm(
              that: this,
              outPlace: outPlace,
              purposeOfVisit: purposeOfVisit,
              outingDate: outingDate,
              outTime: outTime,
              inDate: inDate,
              inTime: inTime);

  /// Submits a new weekend outing application form to VTOP.
  ///
  /// Creates a new weekend outing booking with the provided details. The application will
  /// be submitted to the hostel administration for approval. This method follows a two-step
  /// process: first fetching the student's pre-filled form data, then submitting the complete
  /// form with both user-provided and auto-populated information.
  ///
  /// # Arguments
  ///
  /// * `out_place` - Destination or place to be visited
  /// * `purpose_of_visit` - The reason for the outing (e.g., "Family visit", "Friend's place")
  /// * `outing_date` - The date of the outing in format "DD-MMM-YYYY" (e.g., "23-Mar-2024")
  /// * `out_time` - Expected departure time in "HH:MM" format (e.g., "18:00")
  /// * `contact_number` - Student's contact number during the outing
  ///
  /// # Returns
  ///
  /// Returns a `VtopResult<String>` containing the server response message, which typically includes:
  /// - Success/failure status
  /// - Booking reference number
  /// - Approval status or pending message
  ///
  /// # Errors
  ///
  /// This function will return an error if:
  /// - The session is not authenticated (`VtopError::SessionExpired`)
  /// - Failed to fetch student form information (`VtopError::ParseError`)
  /// - The outing date/time format is invalid
  /// - Network communication fails (`VtopError::NetworkError`)
  /// - The VTOP server rejects the application (`VtopError::VtopServerError`)
  /// - Session expires during the request and re-authentication fails
  ///
  /// # Notes
  ///
  /// This method automatically fetches student information (name, gender, hostel block,
  /// room number, parent contact) from VTOP before submitting the form.
  ///
  /// # Examples
  ///
  /// ```
  /// # async fn example(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Submit a weekend outing application
  /// let response = client.submit_weekend_outing_form(
  ///     "Home, Guntur".to_string(),
  ///     "Family visit".to_string(),
  ///     "23-Mar-2024".to_string(),
  ///     "18:00".to_string(),
  ///     "9876543210".to_string(),
  /// ).await?;
  ///
  /// println!("Booking response: {}", response);
  /// # Ok(())
  /// # }
  /// ```
  ///
  /// ```
  /// # async fn example2(client: &mut VtopClient) -> Result<(), Box<dyn std::error::Error>> {
  /// // Submit for friend visit
  /// let response = client.submit_weekend_outing_form(
  ///     "Friend's residence, Vijayawada".to_string(),
  ///     "Social visit".to_string(),
  ///     "30-Mar-2024".to_string(),
  ///     "16:00".to_string(),
  ///     "9123456789".to_string(),
  /// ).await?;
  ///
  /// if response.contains("success") || response.contains("booked") {
  ///     println!("Weekend outing booked successfully");
  /// }
  /// # Ok(())
  /// # }
  /// ```
  Future<VtopResultString> submitWeekendOutingForm(
          {required String outPlace,
          required String purposeOfVisit,
          required String outingDate,
          required String outTime,
          required String contactNumber}) =>
      RustLib.instance.api
          .crateApiVtopVtopClientVtopClientSubmitWeekendOutingForm(
              that: this,
              outPlace: outPlace,
              purposeOfVisit: purposeOfVisit,
              outingDate: outingDate,
              outTime: outTime,
              contactNumber: contactNumber);
}

@sealed
class VtopResultCoursePageDetailImpl extends RustOpaque
    implements VtopResultCoursePageDetail {
  // Not to be used by end users
  VtopResultCoursePageDetailImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultCoursePageDetailImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultCoursePageDetail,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultCoursePageDetail,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultCoursePageDetailPtr,
  );
}

@sealed
class VtopResultCoursesResponseImpl extends RustOpaque
    implements VtopResultCoursesResponse {
  // Not to be used by end users
  VtopResultCoursesResponseImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultCoursesResponseImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultCoursesResponse,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultCoursesResponse,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultCoursesResponsePtr,
  );
}

@sealed
class VtopResultFacultyDetailsImpl extends RustOpaque
    implements VtopResultFacultyDetails {
  // Not to be used by end users
  VtopResultFacultyDetailsImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultFacultyDetailsImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultFacultyDetails,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultFacultyDetails,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultFacultyDetailsPtr,
  );
}

@sealed
class VtopResultGetFacultyImpl extends RustOpaque
    implements VtopResultGetFaculty {
  // Not to be used by end users
  VtopResultGetFacultyImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultGetFacultyImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultGetFaculty,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultGetFaculty,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultGetFacultyPtr,
  );
}

@sealed
class VtopResultGradeHistoryImpl extends RustOpaque
    implements VtopResultGradeHistory {
  // Not to be used by end users
  VtopResultGradeHistoryImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultGradeHistoryImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultGradeHistory,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultGradeHistory,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultGradeHistoryPtr,
  );
}

@sealed
class VtopResultImpl extends RustOpaque implements VtopResult {
  // Not to be used by end users
  VtopResultImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VtopResult,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopResult,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopResultPtr,
  );
}

@sealed
class VtopResultSemesterDataImpl extends RustOpaque
    implements VtopResultSemesterData {
  // Not to be used by end users
  VtopResultSemesterDataImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultSemesterDataImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultSemesterData,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultSemesterData,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultSemesterDataPtr,
  );
}

@sealed
class VtopResultSlotsResponseImpl extends RustOpaque
    implements VtopResultSlotsResponse {
  // Not to be used by end users
  VtopResultSlotsResponseImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultSlotsResponseImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultSlotsResponse,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultSlotsResponse,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultSlotsResponsePtr,
  );
}

@sealed
class VtopResultStringImpl extends RustOpaque implements VtopResultString {
  // Not to be used by end users
  VtopResultStringImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultStringImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VtopResultString,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopResultString,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultStringPtr,
  );
}

@sealed
class VtopResultStudentProfileImpl extends RustOpaque
    implements VtopResultStudentProfile {
  // Not to be used by end users
  VtopResultStudentProfileImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultStudentProfileImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultStudentProfile,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultStudentProfile,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultStudentProfilePtr,
  );
}

@sealed
class VtopResultTimetableImpl extends RustOpaque
    implements VtopResultTimetable {
  // Not to be used by end users
  VtopResultTimetableImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultTimetableImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib
        .instance.api.rust_arc_increment_strong_count_VtopResultTimetable,
    rustArcDecrementStrongCount: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultTimetable,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultTimetablePtr,
  );
}

@sealed
class VtopResultVecAttendanceDetailRecordImpl extends RustOpaque
    implements VtopResultVecAttendanceDetailRecord {
  // Not to be used by end users
  VtopResultVecAttendanceDetailRecordImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecAttendanceDetailRecordImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecAttendanceDetailRecord,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecAttendanceDetailRecord,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecAttendanceDetailRecordPtr,
  );
}

@sealed
class VtopResultVecAttendanceRecordImpl extends RustOpaque
    implements VtopResultVecAttendanceRecord {
  // Not to be used by end users
  VtopResultVecAttendanceRecordImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecAttendanceRecordImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecAttendanceRecord,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecAttendanceRecord,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecAttendanceRecordPtr,
  );
}

@sealed
class VtopResultVecBiometricRecordImpl extends RustOpaque
    implements VtopResultVecBiometricRecord {
  // Not to be used by end users
  VtopResultVecBiometricRecordImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecBiometricRecordImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecBiometricRecord,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecBiometricRecord,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecBiometricRecordPtr,
  );
}

@sealed
class VtopResultVecGeneralOutingRecordImpl extends RustOpaque
    implements VtopResultVecGeneralOutingRecord {
  // Not to be used by end users
  VtopResultVecGeneralOutingRecordImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecGeneralOutingRecordImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecGeneralOutingRecord,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecGeneralOutingRecord,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecGeneralOutingRecordPtr,
  );
}

@sealed
class VtopResultVecMarksImpl extends RustOpaque implements VtopResultVecMarks {
  // Not to be used by end users
  VtopResultVecMarksImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecMarksImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VtopResultVecMarks,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopResultVecMarks,
    rustArcDecrementStrongCountPtr: RustLib
        .instance.api.rust_arc_decrement_strong_count_VtopResultVecMarksPtr,
  );
}

@sealed
class VtopResultVecPaidPaymentReceiptImpl extends RustOpaque
    implements VtopResultVecPaidPaymentReceipt {
  // Not to be used by end users
  VtopResultVecPaidPaymentReceiptImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecPaidPaymentReceiptImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecPaidPaymentReceipt,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecPaidPaymentReceipt,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecPaidPaymentReceiptPtr,
  );
}

@sealed
class VtopResultVecPendingPaymentReceiptImpl extends RustOpaque
    implements VtopResultVecPendingPaymentReceipt {
  // Not to be used by end users
  VtopResultVecPendingPaymentReceiptImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecPendingPaymentReceiptImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecPendingPaymentReceipt,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecPendingPaymentReceipt,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecPendingPaymentReceiptPtr,
  );
}

@sealed
class VtopResultVecPerExamScheduleRecordImpl extends RustOpaque
    implements VtopResultVecPerExamScheduleRecord {
  // Not to be used by end users
  VtopResultVecPerExamScheduleRecordImpl.frbInternalDcoDecode(
      List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecPerExamScheduleRecordImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecPerExamScheduleRecord,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecPerExamScheduleRecord,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecPerExamScheduleRecordPtr,
  );
}

@sealed
class VtopResultVecU8Impl extends RustOpaque implements VtopResultVecU8 {
  // Not to be used by end users
  VtopResultVecU8Impl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecU8Impl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_VtopResultVecU8,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopResultVecU8,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_VtopResultVecU8Ptr,
  );
}

@sealed
class VtopResultVecWeekendOutingRecordImpl extends RustOpaque
    implements VtopResultVecWeekendOutingRecord {
  // Not to be used by end users
  VtopResultVecWeekendOutingRecordImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  VtopResultVecWeekendOutingRecordImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_VtopResultVecWeekendOutingRecord,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecWeekendOutingRecord,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_VtopResultVecWeekendOutingRecordPtr,
  );
}
